/* database.c generated by valac 0.10.4, the Vala compiler
 * generated from database.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <sqlite3.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <sys/stat.h>
#include <gobject/gvaluecollector.h>


#define ICP_TYPE_DATABASE (icp_database_get_type ())
#define ICP_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_TYPE_DATABASE, icpDatabase))
#define ICP_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_TYPE_DATABASE, icpDatabaseClass))
#define ICP_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_TYPE_DATABASE))
#define ICP_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_TYPE_DATABASE))
#define ICP_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_TYPE_DATABASE, icpDatabaseClass))

typedef struct _icpDatabase icpDatabase;
typedef struct _icpDatabaseClass icpDatabaseClass;
typedef struct _icpDatabasePrivate icpDatabasePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define ICP_PINYIN_TYPE_SEQUENCE (icp_pinyin_sequence_get_type ())
#define ICP_PINYIN_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequence))
#define ICP_PINYIN_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequenceClass))
#define ICP_PINYIN_IS_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_PINYIN_TYPE_SEQUENCE))
#define ICP_PINYIN_IS_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_PINYIN_TYPE_SEQUENCE))
#define ICP_PINYIN_SEQUENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequenceClass))

typedef struct _icpPinyinSequence icpPinyinSequence;
typedef struct _icpPinyinSequenceClass icpPinyinSequenceClass;

#define ICP_PINYIN_TYPE_ID (icp_pinyin_id_get_type ())
#define ICP_PINYIN_ID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_PINYIN_TYPE_ID, icpPinyinId))
#define ICP_PINYIN_ID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_PINYIN_TYPE_ID, icpPinyinIdClass))
#define ICP_PINYIN_IS_ID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_PINYIN_TYPE_ID))
#define ICP_PINYIN_IS_ID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_PINYIN_TYPE_ID))
#define ICP_PINYIN_ID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_PINYIN_TYPE_ID, icpPinyinIdClass))

typedef struct _icpPinyinId icpPinyinId;
typedef struct _icpPinyinIdClass icpPinyinIdClass;
#define _icp_pinyin_id_unref0(var) ((var == NULL) ? NULL : (var = (icp_pinyin_id_unref (var), NULL)))
#define _sqlite3_finalize0(var) ((var == NULL) ? NULL : (var = (sqlite3_finalize (var), NULL)))
#define _sqlite3_close0(var) ((var == NULL) ? NULL : (var = (sqlite3_close (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _icp_pinyin_sequence_unref0(var) ((var == NULL) ? NULL : (var = (icp_pinyin_sequence_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _icpParamSpecDatabase icpParamSpecDatabase;

struct _icpDatabase {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpDatabasePrivate * priv;
};

struct _icpDatabaseClass {
	GTypeClass parent_class;
	void (*finalize) (icpDatabase *self);
};

struct _icpDatabasePrivate {
	gboolean user_db;
};

struct _icpParamSpecDatabase {
	GParamSpec parent_instance;
};


static sqlite3* icp_database_db;
static sqlite3* icp_database_db = NULL;
extern GeeHashSet* icp_pinyin_valid_partial_pinyins;
static gpointer icp_database_parent_class = NULL;

gpointer icp_database_ref (gpointer instance);
void icp_database_unref (gpointer instance);
GParamSpec* icp_param_spec_database (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_value_set_database (GValue* value, gpointer v_object);
void icp_value_take_database (GValue* value, gpointer v_object);
gpointer icp_value_get_database (const GValue* value);
GType icp_database_get_type (void) G_GNUC_CONST;
#define ICP_DATABASE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_TYPE_DATABASE, icpDatabasePrivate))
enum  {
	ICP_DATABASE_DUMMY_PROPERTY
};
#define ICP_DATABASE_PHRASE_LENGTH_MAX 15
static void icp_database_assert_exec (const char* sql);
double icp_database_get_atime (void);
guint64 icp_frontend_get_current_time (void);
gpointer icp_pinyin_sequence_ref (gpointer instance);
void icp_pinyin_sequence_unref (gpointer instance);
GParamSpec* icp_pinyin_param_spec_sequence (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_pinyin_value_set_sequence (GValue* value, gpointer v_object);
void icp_pinyin_value_take_sequence (GValue* value, gpointer v_object);
gpointer icp_pinyin_value_get_sequence (const GValue* value);
GType icp_pinyin_sequence_get_type (void) G_GNUC_CONST;
static void icp_database_internal_query (icpPinyinSequence* pinyins, GeeArrayList* results, gboolean reverse_order, gint pinyins_begin, gint pinyins_end, gint limit, double phrase_adjust);
gint icp_pinyin_sequence_get_size (icpPinyinSequence* self);
gpointer icp_pinyin_id_ref (gpointer instance);
void icp_pinyin_id_unref (gpointer instance);
GParamSpec* icp_pinyin_param_spec_id (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_pinyin_value_set_id (GValue* value, gpointer v_object);
void icp_pinyin_value_take_id (GValue* value, gpointer v_object);
gpointer icp_pinyin_value_get_id (const GValue* value);
GType icp_pinyin_id_get_type (void) G_GNUC_CONST;
icpPinyinId* icp_pinyin_sequence_get_id (icpPinyinSequence* self, gint index);
gint icp_pinyin_id_get_consonant (icpPinyinId* self);
gint icp_pinyin_id_get_vowel (icpPinyinId* self);
static void icp_database_load_databases (void);
const char* icp_config_get_global_database (void);
const char* icp_config_get_user_database (void);
void icp_database_batch_insert (GeeArrayList* phrases, GeeArrayList* sequences, GeeArrayList* freqs);
static double* _double_dup (double* self);
void icp_database_insert (const char* phrase, icpPinyinSequence* sequence, double base_freq, double freq_increase, gboolean lookup_first);
gboolean icp_database_reverse_convert (const char* content, icpPinyinSequence** pinyins);
icpPinyinId* icp_pinyin_id_new_id (gint cid, gint vid);
icpPinyinId* icp_pinyin_id_construct_id (GType object_type, gint cid, gint vid);
icpPinyinId* icp_pinyin_id_new (const char* pinyin);
icpPinyinId* icp_pinyin_id_construct (GType object_type, const char* pinyin);
icpPinyinSequence* icp_pinyin_sequence_new_ids (GeeArrayList* ids);
icpPinyinSequence* icp_pinyin_sequence_construct_ids (GType object_type, GeeArrayList* ids);
void icp_database_query (icpPinyinSequence* pinyins, GeeArrayList* candidates, gint limit, double phrase_adjust);
char* icp_database_greedy_convert (icpPinyinSequence* pinyins, double phrase_adjust);
char* icp_pinyin_sequence_get (icpPinyinSequence* self, gint index);
void icp_database_init (void);
const char* icp_config_get_user_cache_path (void);
static icpDatabase* icp_database_new (void);
static icpDatabase* icp_database_construct (GType object_type);
static void icp_database_finalize (icpDatabase* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



static gint _sqlite3_exec (sqlite3* self, const char* sql, sqlite3_callback sqlite3_callback, void* sqlite3_callback_target, char** errmsg) {
	gint result = 0;
	const char* sqlite_errmsg;
	gint ec;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (sql != NULL, 0);
	if (errmsg != NULL) {
		*errmsg = NULL;
	}
	sqlite_errmsg = NULL;
	ec = sqlite3_exec (self, sql, sqlite3_callback, sqlite3_callback_target, (char**) (&sqlite_errmsg));
	if ((errmsg) != NULL) {
		char* _tmp0_;
		*errmsg = (_tmp0_ = g_strdup (sqlite_errmsg), _g_free0 (*errmsg), _tmp0_);
	}
	sqlite3_free ((void*) sqlite_errmsg);
	result = ec;
	return result;
}


static void icp_database_assert_exec (const char* sql) {
	char* error_msg;
	char* _tmp0_ = NULL;
	gint _tmp1_;
	char* _tmp2_;
	gint ret;
	g_return_if_fail (sql != NULL);
	error_msg = NULL;
	ret = (_tmp1_ = _sqlite3_exec (icp_database_db, sql, NULL, NULL, &_tmp0_), error_msg = (_tmp2_ = _tmp0_, _g_free0 (error_msg), _tmp2_), _tmp1_);
	if (ret != SQLITE_OK) {
		fprintf (stderr, "FATAL SQLITE ERROR: %s\nSQL: %s\n", error_msg, sql);
		g_assert_not_reached ();
	}
	_g_free0 (error_msg);
}


double icp_database_get_atime (void) {
	double result = 0.0;
	result = ((double) icp_frontend_get_current_time ()) / ((((double) 24) * 3600) * 1000000);
	return result;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


static void icp_database_internal_query (icpPinyinSequence* pinyins, GeeArrayList* results, gboolean reverse_order, gint pinyins_begin, gint pinyins_end, gint limit, double phrase_adjust) {
	gboolean _tmp0_ = FALSE;
	char* where;
	char* query;
	char* subquery;
	char* _tmp26_;
	char* _tmp27_;
	sqlite3_stmt* stmt;
	sqlite3_stmt* _tmp30_ = NULL;
	gint _tmp31_;
	sqlite3_stmt* _tmp32_;
	g_return_if_fail (ICP_PINYIN_IS_SEQUENCE (pinyins));
	g_return_if_fail (GEE_IS_ARRAY_LIST (results));
	if (pinyins_begin < 0) {
		pinyins_begin = 0;
	}
	if (pinyins_end < 0) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = pinyins_end > icp_pinyin_sequence_get_size (pinyins);
	}
	if (_tmp0_) {
		pinyins_end = icp_pinyin_sequence_get_size (pinyins);
	}
	where = g_strdup ("");
	query = g_strdup ("SELECT phrase, freqadj FROM (");
	subquery = g_strdup ("");
	{
		gint id;
		id = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_ = FALSE;
				icpPinyinId* pinyin_id;
				char* _tmp22_;
				char* _tmp23_;
				char* _tmp24_;
				char* _tmp25_;
				if (!_tmp1_) {
					id = id + 1;
				}
				_tmp1_ = FALSE;
				if (!(id < icp_pinyin_sequence_get_size (pinyins))) {
					break;
				}
				if (id > ICP_DATABASE_PHRASE_LENGTH_MAX) {
					_tmp2_ = TRUE;
				} else {
					_tmp2_ = (id + pinyins_begin) >= pinyins_end;
				}
				if (_tmp2_) {
					break;
				}
				pinyin_id = NULL;
				if (!reverse_order) {
					icpPinyinId* _tmp3_;
					gint cid;
					gint vid;
					gboolean _tmp4_ = FALSE;
					gboolean _tmp5_ = FALSE;
					gboolean _tmp6_ = FALSE;
					gboolean _tmp7_ = FALSE;
					char* _tmp9_;
					char* _tmp10_;
					pinyin_id = (_tmp3_ = icp_pinyin_sequence_get_id (pinyins, id + pinyins_begin), _icp_pinyin_id_unref0 (pinyin_id), _tmp3_);
					cid = icp_pinyin_id_get_consonant (pinyin_id);
					vid = icp_pinyin_id_get_vowel (pinyin_id);
					if (cid == 0) {
						_tmp4_ = vid == (-1);
					} else {
						_tmp4_ = FALSE;
					}
					if (_tmp4_) {
						_icp_pinyin_id_unref0 (pinyin_id);
						break;
					}
					if (vid == (-1)) {
						_tmp7_ = id == 0;
					} else {
						_tmp7_ = FALSE;
					}
					if (_tmp7_) {
						_tmp6_ = limit != 1;
					} else {
						_tmp6_ = FALSE;
					}
					if (_tmp6_) {
						_tmp5_ = icp_pinyin_sequence_get_size (pinyins) == 1;
					} else {
						_tmp5_ = FALSE;
					}
					if (_tmp5_) {
						_icp_pinyin_id_unref0 (pinyin_id);
						break;
					}
					if (string_get_length (where) != 0) {
						char* _tmp8_;
						where = (_tmp8_ = g_strconcat (where, " AND ", NULL), _g_free0 (where), _tmp8_);
					}
					where = (_tmp10_ = g_strconcat (where, _tmp9_ = g_strdup_printf ("s%d=%d", id, cid), NULL), _g_free0 (where), _tmp10_);
					_g_free0 (_tmp9_);
					if (vid != (-1)) {
						char* _tmp11_;
						char* _tmp12_;
						where = (_tmp12_ = g_strconcat (where, _tmp11_ = g_strdup_printf (" AND y%d=%d", id, vid), NULL), _g_free0 (where), _tmp12_);
						_g_free0 (_tmp11_);
					}
				} else {
					char* _tmp13_;
					where = (_tmp13_ = g_strdup (""), _g_free0 (where), _tmp13_);
					{
						gint p;
						p = id;
						{
							gboolean _tmp14_;
							_tmp14_ = TRUE;
							while (TRUE) {
								icpPinyinId* _tmp15_;
								char* _tmp17_;
								char* _tmp18_;
								if (!_tmp14_) {
									p = p - 1;
								}
								_tmp14_ = FALSE;
								if (!(p >= 0)) {
									break;
								}
								pinyin_id = (_tmp15_ = icp_pinyin_sequence_get_id (pinyins, (pinyins_end - 1) - p), _icp_pinyin_id_unref0 (pinyin_id), _tmp15_);
								if (string_get_length (where) != 0) {
									char* _tmp16_;
									where = (_tmp16_ = g_strconcat (where, " AND ", NULL), _g_free0 (where), _tmp16_);
								}
								where = (_tmp18_ = g_strconcat (where, _tmp17_ = g_strdup_printf ("s%d=%d", id - p, icp_pinyin_id_get_consonant (pinyin_id)), NULL), _g_free0 (where), _tmp18_);
								_g_free0 (_tmp17_);
								if (icp_pinyin_id_get_vowel (pinyin_id) >= 0) {
									char* _tmp19_;
									char* _tmp20_;
									where = (_tmp20_ = g_strconcat (where, _tmp19_ = g_strdup_printf (" AND y%d=%d", id - p, icp_pinyin_id_get_vowel (pinyin_id)), NULL), _g_free0 (where), _tmp20_);
									_g_free0 (_tmp19_);
								}
							}
						}
					}
				}
				if (id > 0) {
					char* _tmp21_;
					subquery = (_tmp21_ = g_strconcat (subquery, " UNION ALL ", NULL), _g_free0 (subquery), _tmp21_);
				}
				subquery = (_tmp23_ = g_strconcat (subquery, _tmp22_ = g_strdup_printf ("SELECT phrase, freq*%.3f AS freqadj FROM main.py_phrase_%d WHERE %s", (id + 1) * pow (1.0 + ((double) id), phrase_adjust), id, where), NULL), _g_free0 (subquery), _tmp23_);
				_g_free0 (_tmp22_);
				subquery = (_tmp25_ = g_strconcat (subquery, _tmp24_ = g_strdup_printf (" UNION ALL SELECT phrase, freq*%.3f*max((32-%.3lf+atime)/32.0, %.3f)" " AS freqadj FROM userdb.py_phrase_%d WHERE %s", (id + 1) * pow (1.0 + ((double) id), phrase_adjust), icp_database_get_atime (), pow (0.3, (double) (1 + id)), id, where), NULL), _g_free0 (subquery), _tmp25_);
				_g_free0 (_tmp24_);
				_icp_pinyin_id_unref0 (pinyin_id);
			}
		}
	}
	if (string_get_length (subquery) == 0) {
		_g_free0 (subquery);
		_g_free0 (query);
		_g_free0 (where);
		return;
	}
	query = (_tmp27_ = g_strconcat (query, _tmp26_ = g_strconcat (subquery, ") GROUP BY phrase ORDER BY freqadj DESC", NULL), NULL), _g_free0 (query), _tmp27_);
	_g_free0 (_tmp26_);
	if (limit > 0) {
		char* _tmp28_;
		char* _tmp29_;
		query = (_tmp29_ = g_strconcat (query, _tmp28_ = g_strdup_printf (" LIMIT %d", limit), NULL), _g_free0 (query), _tmp29_);
		_g_free0 (_tmp28_);
	}
	stmt = NULL;
	if ((_tmp31_ = sqlite3_prepare_v2 (icp_database_db, query, -1, &_tmp30_, NULL), stmt = (_tmp32_ = _tmp30_, _sqlite3_finalize0 (stmt), _tmp32_), _tmp31_) != SQLITE_OK) {
		_sqlite3_finalize0 (stmt);
		_g_free0 (subquery);
		_g_free0 (query);
		_g_free0 (where);
		return;
	}
	{
		gboolean running;
		running = TRUE;
		{
			gboolean _tmp33_;
			_tmp33_ = TRUE;
			while (TRUE) {
				if (!_tmp33_) {
				}
				_tmp33_ = FALSE;
				if (!running) {
					break;
				}
				switch (sqlite3_step (stmt)) {
					case SQLITE_ROW:
					{
						{
							char* phrase;
							phrase = g_strdup (sqlite3_column_text (stmt, 0));
							gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (results), phrase);
							_g_free0 (phrase);
							break;
						}
					}
					case SQLITE_DONE:
					{
						{
							running = FALSE;
							break;
						}
					}
					case SQLITE_BUSY:
					{
						{
							g_usleep ((gulong) 1024);
							break;
						}
					}
					default:
					{
						{
							running = FALSE;
							break;
						}
					}
				}
			}
		}
	}
	_sqlite3_finalize0 (stmt);
	_g_free0 (subquery);
	_g_free0 (query);
	_g_free0 (where);
}


static void icp_database_load_databases (void) {
	sqlite3* _tmp0_ = NULL;
	gint _tmp1_;
	sqlite3* _tmp2_;
	char* _tmp3_;
	GString* sql_builder;
	g_assert ((_tmp1_ = sqlite3_open_v2 (icp_config_get_global_database (), &_tmp0_, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL), icp_database_db = (_tmp2_ = _tmp0_, _sqlite3_close0 (icp_database_db), _tmp2_), _tmp1_) == SQLITE_OK);
	_sqlite3_exec (icp_database_db, "PRAGMA cache_size = 16384;\n PRAGMA temp_store = MEMORY;\n" "PRAGMA synchronous=NORMAL;\n PRAGMA journal_mode=PERSIST;\n", NULL, NULL, NULL);
	icp_database_assert_exec (_tmp3_ = g_strdup_printf ("ATTACH DATABASE \"%s\" AS userdb;", icp_config_get_user_database ()));
	_g_free0 (_tmp3_);
	sql_builder = g_string_new ("");
	g_string_append (sql_builder, "BEGIN TRANSACTION;\n");
	{
		gint i;
		i = 0;
		{
			gboolean _tmp4_;
			_tmp4_ = TRUE;
			while (TRUE) {
				char* _tmp5_;
				char* columns;
				char* _tmp11_;
				char* _tmp12_;
				if (!_tmp4_) {
					i++;
				}
				_tmp4_ = FALSE;
				if (!(i <= ICP_DATABASE_PHRASE_LENGTH_MAX)) {
					break;
				}
				g_string_append (sql_builder, _tmp5_ = g_strdup_printf ("CREATE TABLE IF NOT EXISTS userdb.py_phrase_%d", i));
				_g_free0 (_tmp5_);
				g_string_append (sql_builder, "(phrase TEXT, freq DOUBLE, atime DOUBLE");
				{
					gint j;
					j = 0;
					{
						gboolean _tmp6_;
						_tmp6_ = TRUE;
						while (TRUE) {
							char* _tmp7_;
							if (!_tmp6_) {
								j++;
							}
							_tmp6_ = FALSE;
							if (!(j <= i)) {
								break;
							}
							g_string_append (sql_builder, _tmp7_ = g_strdup_printf (",s%d INTEGER,y%d INTEGER", j, j));
							_g_free0 (_tmp7_);
						}
					}
				}
				g_string_append (sql_builder, ");\n");
				columns = g_strdup ("");
				if (i < 3) {
					{
						gint j;
						j = 0;
						{
							gboolean _tmp8_;
							_tmp8_ = TRUE;
							while (TRUE) {
								char* _tmp9_;
								char* _tmp10_;
								if (!_tmp8_) {
									j++;
								}
								_tmp8_ = FALSE;
								if (!(j <= i)) {
									break;
								}
								columns = (_tmp10_ = g_strconcat (columns, _tmp9_ = g_strdup_printf ("s%d,y%d,", j, j), NULL), _g_free0 (columns), _tmp10_);
								_g_free0 (_tmp9_);
							}
						}
					}
				}
				columns = (_tmp11_ = g_strconcat (columns, "phrase", NULL), _g_free0 (columns), _tmp11_);
				g_string_append (sql_builder, _tmp12_ = g_strdup_printf ("CREATE UNIQUE INDEX IF NOT EXISTS userdb.index_%d_%d ON py_phrase_%d (" \
"%s);\n", i, 0, i, columns));
				_g_free0 (_tmp12_);
				if (i >= 2) {
					char* _tmp13_;
					g_string_append (sql_builder, _tmp13_ = g_strdup_printf ("CREATE INDEX IF NOT EXISTS userdb.index_%d_%d ON py_phrase_%d (s0, y0," \
" s1, y1, s2, y2);\n", i, 1, i));
					_g_free0 (_tmp13_);
				}
				if (i >= 3) {
					char* _tmp14_;
					g_string_append (sql_builder, _tmp14_ = g_strdup_printf ("CREATE INDEX IF NOT EXISTS userdb.index_%d_%d ON py_phrase_%d (s0, s1," \
" s2, s3);\n", i, 2, i));
					_g_free0 (_tmp14_);
				}
				_g_free0 (columns);
			}
		}
	}
	g_string_append (sql_builder, "COMMIT;");
	icp_database_assert_exec (sql_builder->str);
	_g_string_free0 (sql_builder);
}


static double* _double_dup (double* self) {
	double* dup;
	dup = g_new0 (double, 1);
	memcpy (dup, self, sizeof (double));
	return dup;
}


static gpointer __double_dup0 (gpointer self) {
	return self ? _double_dup (self) : NULL;
}


void icp_database_batch_insert (GeeArrayList* phrases, GeeArrayList* sequences, GeeArrayList* freqs) {
	gint count;
	GString* sql_builder;
	g_return_if_fail (GEE_IS_ARRAY_LIST (phrases));
	g_return_if_fail (GEE_IS_ARRAY_LIST (sequences));
	g_return_if_fail (GEE_IS_ARRAY_LIST (freqs));
	count = gee_collection_get_size (GEE_COLLECTION (phrases));
	if (gee_collection_get_size (GEE_COLLECTION (sequences)) < count) {
		count = gee_collection_get_size (GEE_COLLECTION (sequences));
	}
	if (gee_collection_get_size (GEE_COLLECTION (freqs)) < count) {
		count = gee_collection_get_size (GEE_COLLECTION (freqs));
	}
	sql_builder = g_string_new ("");
	g_string_append (sql_builder, "BEGIN;\n");
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				char* phrase;
				icpPinyinSequence* sequence;
				double* _tmp1_;
				double freq;
				gboolean _tmp4_ = FALSE;
				gboolean _tmp5_ = FALSE;
				gint length;
				char* _tmp6_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < count)) {
					break;
				}
				phrase = (char*) gee_abstract_list_get (GEE_ABSTRACT_LIST (phrases), i);
				sequence = (icpPinyinSequence*) gee_abstract_list_get (GEE_ABSTRACT_LIST (sequences), i);
				_tmp1_ = (double*) gee_abstract_list_get (GEE_ABSTRACT_LIST (freqs), i);
				if (_tmp1_ == NULL) {
					gint _tmp2_;
					double* _tmp3_;
					_tmp1_ = (_tmp3_ = __double_dup0 ((_tmp2_ = 1000, &_tmp2_)), _g_free0 (_tmp1_), _tmp3_);
				}
				freq = *_tmp1_;
				if (icp_pinyin_sequence_get_size (sequence) != string_get_length (phrase)) {
					_tmp5_ = TRUE;
				} else {
					_tmp5_ = icp_pinyin_sequence_get_size (sequence) > (ICP_DATABASE_PHRASE_LENGTH_MAX + 1);
				}
				if (_tmp5_) {
					_tmp4_ = TRUE;
				} else {
					_tmp4_ = icp_pinyin_sequence_get_size (sequence) == 0;
				}
				if (_tmp4_) {
					_g_free0 (_tmp1_);
					_icp_pinyin_sequence_unref0 (sequence);
					_g_free0 (phrase);
					continue;
				}
				length = icp_pinyin_sequence_get_size (sequence);
				g_string_append (sql_builder, _tmp6_ = g_strdup_printf ("INSERT OR REPLACE INTO userdb.py_phrase_%d VALUES('%s',%.3lf,%.3lf", length - 1, phrase, freq, icp_database_get_atime ()));
				_g_free0 (_tmp6_);
				{
					gint j;
					j = 0;
					{
						gboolean _tmp7_;
						_tmp7_ = TRUE;
						while (TRUE) {
							icpPinyinId* id;
							char* _tmp8_;
							if (!_tmp7_) {
								j++;
							}
							_tmp7_ = FALSE;
							if (!(j < length)) {
								break;
							}
							id = icp_pinyin_sequence_get_id (sequence, j);
							if (icp_pinyin_id_get_vowel (id) < 0) {
								_icp_pinyin_id_unref0 (id);
								_g_free0 (_tmp1_);
								_icp_pinyin_sequence_unref0 (sequence);
								_g_free0 (phrase);
								_g_string_free0 (sql_builder);
								return;
							}
							g_string_append (sql_builder, _tmp8_ = g_strdup_printf (",%d,%d", icp_pinyin_id_get_consonant (id), icp_pinyin_id_get_vowel (id)));
							_g_free0 (_tmp8_);
							_icp_pinyin_id_unref0 (id);
						}
					}
				}
				g_string_append (sql_builder, ");\n");
				_g_free0 (_tmp1_);
				_icp_pinyin_sequence_unref0 (sequence);
				_g_free0 (phrase);
			}
		}
	}
	g_string_append (sql_builder, "COMMIT;\n");
	icp_database_assert_exec (sql_builder->str);
	_g_string_free0 (sql_builder);
}


void icp_database_insert (const char* phrase, icpPinyinSequence* sequence, double base_freq, double freq_increase, gboolean lookup_first) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gint length;
	GString* sql_builder;
	char* where;
	double freq;
	char* _tmp8_;
	g_return_if_fail (phrase != NULL);
	g_return_if_fail (ICP_PINYIN_IS_SEQUENCE (sequence));
	if (icp_pinyin_sequence_get_size (sequence) != string_get_length (phrase)) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = icp_pinyin_sequence_get_size (sequence) > (ICP_DATABASE_PHRASE_LENGTH_MAX + 1);
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = icp_pinyin_sequence_get_size (sequence) == 0;
	}
	if (_tmp0_) {
		return;
	}
	length = icp_pinyin_sequence_get_size (sequence);
	sql_builder = g_string_new ("");
	where = g_strdup_printf ("phrase=\"%s\"", phrase);
	if (lookup_first) {
		char* _tmp2_;
		g_string_append (sql_builder, _tmp2_ = g_strdup_printf ("INSERT OR IGNORE INTO userdb.py_phrase_%d VALUES(", length - 1));
		_g_free0 (_tmp2_);
	} else {
		char* _tmp3_;
		g_string_append (sql_builder, _tmp3_ = g_strdup_printf ("INSERT OR REPLACE INTO userdb.py_phrase_%d VALUES(", length - 1));
		_g_free0 (_tmp3_);
	}
	freq = base_freq;
	if (freq < 0) {
		freq = (-freq) / length;
	}
	if (lookup_first) {
		char* query;
		sqlite3_stmt* stmt;
		sqlite3_stmt* _tmp4_ = NULL;
		gint _tmp5_;
		sqlite3_stmt* _tmp6_;
		query = g_strdup_printf ("SELECT freq FROM main.py_phrase_%d WHERE phrase=\"%s\" LIMIT 1", length - 1, phrase);
		stmt = NULL;
		if ((_tmp5_ = sqlite3_prepare_v2 (icp_database_db, query, -1, &_tmp4_, NULL), stmt = (_tmp6_ = _tmp4_, _sqlite3_finalize0 (stmt), _tmp6_), _tmp5_) == SQLITE_OK) {
			{
				gboolean running;
				running = TRUE;
				{
					gboolean _tmp7_;
					_tmp7_ = TRUE;
					while (TRUE) {
						if (!_tmp7_) {
						}
						_tmp7_ = FALSE;
						if (!running) {
							break;
						}
						switch (sqlite3_step (stmt)) {
							case SQLITE_ROW:
							{
								freq = (double) sqlite3_column_double (stmt, 0);
								break;
							}
							case SQLITE_BUSY:
							{
								g_usleep ((gulong) 1024);
								break;
							}
							default:
							{
								running = FALSE;
								break;
							}
						}
					}
				}
			}
		}
		_sqlite3_finalize0 (stmt);
		_g_free0 (query);
	}
	g_string_append (sql_builder, _tmp8_ = g_strdup_printf ("'%s',%lf,%lf", phrase, freq, icp_database_get_atime ()));
	_g_free0 (_tmp8_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				icpPinyinId* id;
				char* _tmp10_;
				char* _tmp11_;
				char* _tmp12_;
				if (!_tmp9_) {
					i++;
				}
				_tmp9_ = FALSE;
				if (!(i < length)) {
					break;
				}
				id = icp_pinyin_sequence_get_id (sequence, i);
				if (icp_pinyin_id_get_vowel (id) < 0) {
					_icp_pinyin_id_unref0 (id);
					_g_free0 (where);
					_g_string_free0 (sql_builder);
					return;
				}
				where = (_tmp11_ = g_strconcat (where, _tmp10_ = g_strdup_printf (" AND s%d=%d AND y%d=%d", i, icp_pinyin_id_get_consonant (id), i, icp_pinyin_id_get_vowel (id)), NULL), _g_free0 (where), _tmp11_);
				_g_free0 (_tmp10_);
				g_string_append (sql_builder, _tmp12_ = g_strdup_printf (",%d,%d", icp_pinyin_id_get_consonant (id), icp_pinyin_id_get_vowel (id)));
				_g_free0 (_tmp12_);
				_icp_pinyin_id_unref0 (id);
			}
		}
	}
	g_string_append (sql_builder, ");");
	icp_database_assert_exec (sql_builder->str);
	if (lookup_first) {
		double atime;
		char* query;
		sqlite3_stmt* stmt;
		sqlite3_stmt* _tmp13_ = NULL;
		gint _tmp14_;
		sqlite3_stmt* _tmp15_;
		atime = icp_database_get_atime ();
		query = g_strdup_printf ("SELECT atime, freq FROM userdb.py_phrase_%d WHERE %s LIMIT 1", length - 1, where);
		stmt = NULL;
		if ((_tmp14_ = sqlite3_prepare_v2 (icp_database_db, query, -1, &_tmp13_, NULL), stmt = (_tmp15_ = _tmp13_, _sqlite3_finalize0 (stmt), _tmp15_), _tmp14_) == SQLITE_OK) {
			{
				gboolean running;
				running = TRUE;
				{
					gboolean _tmp16_;
					_tmp16_ = TRUE;
					while (TRUE) {
						if (!_tmp16_) {
						}
						_tmp16_ = FALSE;
						if (!running) {
							break;
						}
						switch (sqlite3_step (stmt)) {
							case SQLITE_ROW:
							{
								atime = sqlite3_column_double (stmt, 0);
								freq = sqlite3_column_double (stmt, 1);
								break;
							}
							case SQLITE_BUSY:
							{
								g_usleep ((gulong) 1024);
								break;
							}
							default:
							{
								running = FALSE;
								break;
							}
						}
					}
				}
			}
		}
		atime = icp_database_get_atime () - atime;
		if (atime < 1.0) {
			char* _tmp17_;
			icp_database_assert_exec (_tmp17_ = g_strdup_printf ("UPDATE userdb.py_phrase_%d SET freq=freq+%.3lf, atime=%lf WHERE %s", length - 1, freq_increase, icp_database_get_atime (), where));
			_g_free0 (_tmp17_);
		} else {
			char* _tmp18_;
			icp_database_assert_exec (_tmp18_ = g_strdup_printf ("UPDATE userdb.py_phrase_%d SET atime=%lf WHERE %s", length - 1, icp_database_get_atime (), where));
			_g_free0 (_tmp18_);
		}
		_sqlite3_finalize0 (stmt);
		_g_free0 (query);
	}
	_g_free0 (where);
	_g_string_free0 (sql_builder);
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


gboolean icp_database_reverse_convert (const char* content, icpPinyinSequence** pinyins) {
	gboolean result = FALSE;
	gboolean successful;
	GeeArrayList* ids;
	icpPinyinSequence* _tmp20_;
	g_return_val_if_fail (content != NULL, FALSE);
	if (pinyins != NULL) {
		*pinyins = NULL;
	}
	successful = TRUE;
	ids = gee_array_list_new (ICP_PINYIN_TYPE_ID, (GBoxedCopyFunc) icp_pinyin_id_ref, icp_pinyin_id_unref, NULL);
	{
		gint pos;
		pos = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint phrase_length_max;
				gint matched_length;
				if (!_tmp0_) {
				}
				_tmp0_ = FALSE;
				if (!(pos < string_get_length (content))) {
					break;
				}
				phrase_length_max = 5;
				if ((pos + phrase_length_max) >= string_get_length (content)) {
					phrase_length_max = (((gint) string_get_length (content)) - pos) - 1;
				}
				matched_length = 0;
				{
					gint phrase_length;
					phrase_length = phrase_length_max;
					{
						gboolean _tmp1_;
						_tmp1_ = TRUE;
						while (TRUE) {
							char* query;
							char* _tmp6_;
							char* _tmp7_;
							char* _tmp8_;
							sqlite3_stmt* stmt;
							sqlite3_stmt* _tmp9_ = NULL;
							gint _tmp10_;
							sqlite3_stmt* _tmp11_;
							if (!_tmp1_) {
								phrase_length--;
							}
							_tmp1_ = FALSE;
							if (!(phrase_length >= 0)) {
								break;
							}
							query = g_strdup ("SELECT ");
							{
								gint i;
								i = 0;
								{
									gboolean _tmp2_;
									_tmp2_ = TRUE;
									while (TRUE) {
										gchar _tmp3_ = '\0';
										char* _tmp4_;
										char* _tmp5_;
										if (!_tmp2_) {
											i++;
										}
										_tmp2_ = FALSE;
										if (!(i <= phrase_length)) {
											break;
										}
										if (i == phrase_length) {
											_tmp3_ = ' ';
										} else {
											_tmp3_ = ',';
										}
										query = (_tmp5_ = g_strconcat (query, _tmp4_ = g_strdup_printf ("s%d,y%d%c", i, i, (gint) _tmp3_), NULL), _g_free0 (query), _tmp5_);
										_g_free0 (_tmp4_);
									}
								}
							}
							query = (_tmp8_ = g_strconcat (query, _tmp7_ = g_strdup_printf (" FROM main.py_phrase_%d WHERE phrase=\"%s\" LIMIT 1", phrase_length, _tmp6_ = string_slice (content, (glong) pos, (glong) ((pos + phrase_length) + 1))), NULL), _g_free0 (query), _tmp8_);
							_g_free0 (_tmp7_);
							_g_free0 (_tmp6_);
							stmt = NULL;
							if ((_tmp10_ = sqlite3_prepare_v2 (icp_database_db, query, -1, &_tmp9_, NULL), stmt = (_tmp11_ = _tmp9_, _sqlite3_finalize0 (stmt), _tmp11_), _tmp10_) != SQLITE_OK) {
								_sqlite3_finalize0 (stmt);
								_g_free0 (query);
								continue;
							}
							{
								gboolean running;
								running = TRUE;
								{
									gboolean _tmp12_;
									_tmp12_ = TRUE;
									while (TRUE) {
										if (!_tmp12_) {
										}
										_tmp12_ = FALSE;
										if (!running) {
											break;
										}
										switch (sqlite3_step (stmt)) {
											case SQLITE_ROW:
											{
												if (matched_length == 0) {
													matched_length = phrase_length + 1;
													{
														gint i;
														i = 0;
														{
															gboolean _tmp13_;
															_tmp13_ = TRUE;
															while (TRUE) {
																icpPinyinId* _tmp14_;
																if (!_tmp13_) {
																	i++;
																}
																_tmp13_ = FALSE;
																if (!(i <= phrase_length)) {
																	break;
																}
																gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (ids), _tmp14_ = icp_pinyin_id_new_id (sqlite3_column_int (stmt, i * 2), sqlite3_column_int (stmt, (i * 2) + 1)));
																_icp_pinyin_id_unref0 (_tmp14_);
															}
														}
													}
												}
												break;
											}
											case SQLITE_BUSY:
											{
												g_usleep ((gulong) 1024);
												break;
											}
											default:
											{
												running = FALSE;
												break;
											}
										}
									}
								}
							}
							if (matched_length > 0) {
								_sqlite3_finalize0 (stmt);
								_g_free0 (query);
								break;
							}
							_sqlite3_finalize0 (stmt);
							_g_free0 (query);
						}
					}
				}
				if (matched_length == 0) {
					gint pinyin_length;
					pinyin_length = 6;
					if ((pos + pinyin_length) >= string_get_length (content)) {
						pinyin_length = ((gint) string_get_length (content)) - pos;
					}
					{
						gboolean _tmp15_;
						_tmp15_ = TRUE;
						while (TRUE) {
							char* _tmp16_;
							gboolean _tmp17_;
							if (!_tmp15_) {
								pinyin_length--;
							}
							_tmp15_ = FALSE;
							if (!(pinyin_length > 0)) {
								break;
							}
							if ((_tmp17_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (icp_pinyin_valid_partial_pinyins), _tmp16_ = string_slice (content, (glong) pos, (glong) (pos + pinyin_length))), _g_free0 (_tmp16_), _tmp17_)) {
								char* _tmp18_;
								icpPinyinId* _tmp19_;
								matched_length = pinyin_length;
								gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (ids), _tmp19_ = icp_pinyin_id_new (_tmp18_ = string_slice (content, (glong) pos, (glong) (pos + pinyin_length))));
								_icp_pinyin_id_unref0 (_tmp19_);
								_g_free0 (_tmp18_);
								break;
							}
						}
					}
				}
				if (matched_length == 0) {
					successful = FALSE;
					pos++;
				} else {
					pos = pos + matched_length;
				}
			}
		}
	}
	*pinyins = (_tmp20_ = icp_pinyin_sequence_new_ids (ids), _icp_pinyin_sequence_unref0 (*pinyins), _tmp20_);
	result = successful;
	_g_object_unref0 (ids);
	return result;
}


void icp_database_query (icpPinyinSequence* pinyins, GeeArrayList* candidates, gint limit, double phrase_adjust) {
	g_return_if_fail (ICP_PINYIN_IS_SEQUENCE (pinyins));
	g_return_if_fail (GEE_IS_ARRAY_LIST (candidates));
	icp_database_internal_query (pinyins, candidates, FALSE, 0, -1, limit, phrase_adjust);
}


char* icp_database_greedy_convert (icpPinyinSequence* pinyins, double phrase_adjust) {
	char* result = NULL;
	char* r;
	GeeArrayList* query_result;
	g_return_val_if_fail (ICP_PINYIN_IS_SEQUENCE (pinyins), NULL);
	r = g_strdup ("");
	if (icp_pinyin_sequence_get_size (pinyins) == 0) {
		result = r;
		return result;
	}
	query_result = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	;
	{
		gint id;
		id = (gint) icp_pinyin_sequence_get_size (pinyins);
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				char* phrase;
				gint match_length;
				if (!_tmp0_) {
				}
				_tmp0_ = FALSE;
				if (!(id > 0)) {
					break;
				}
				icp_database_internal_query (pinyins, query_result, TRUE, 0, id, 1, phrase_adjust);
				phrase = g_strdup ("");
				if (gee_collection_get_size (GEE_COLLECTION (query_result)) > 0) {
					char* _tmp1_;
					phrase = (_tmp1_ = (char*) gee_abstract_list_get (GEE_ABSTRACT_LIST (query_result), 0), _g_free0 (phrase), _tmp1_);
				}
				match_length = (gint) string_get_length (phrase);
				if (match_length == 0) {
					char* _tmp2_;
					char* _tmp3_;
					r = (_tmp3_ = g_strconcat (_tmp2_ = icp_pinyin_sequence_get (pinyins, id - 1), r, NULL), _g_free0 (r), _tmp3_);
					_g_free0 (_tmp2_);
					id--;
				} else {
					char* _tmp4_;
					r = (_tmp4_ = g_strconcat (phrase, r, NULL), _g_free0 (r), _tmp4_);
					id = id - match_length;
				}
				gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (query_result));
				_g_free0 (phrase);
			}
		}
	}
	result = r;
	_g_object_unref0 (query_result);
	return result;
}


void icp_database_init (void) {
	char* path;
	path = g_strdup ("");
	{
		char** _tmp0_;
		char** dir_collection;
		int dir_collection_length1;
		int dir_it;
		dir_collection = _tmp0_ = g_strsplit (icp_config_get_user_cache_path (), "/", 0);
		dir_collection_length1 = _vala_array_length (_tmp0_);
		for (dir_it = 0; dir_it < _vala_array_length (_tmp0_); dir_it = dir_it + 1) {
			char* dir;
			dir = g_strdup (dir_collection[dir_it]);
			{
				char* _tmp1_;
				char* _tmp2_;
				path = (_tmp2_ = g_strconcat (path, _tmp1_ = g_strdup_printf ("/%s", dir), NULL), _g_free0 (path), _tmp2_);
				_g_free0 (_tmp1_);
				mkdir (path, S_IRWXU);
				_g_free0 (dir);
			}
		}
		dir_collection = (_vala_array_free (dir_collection, dir_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	icp_database_load_databases ();
	_g_free0 (path);
}


static icpDatabase* icp_database_construct (GType object_type) {
	icpDatabase* self = (icpDatabase*) g_type_create_instance (object_type);
	return self;
}


static icpDatabase* icp_database_new (void) {
	return icp_database_construct (ICP_TYPE_DATABASE);
}


static void icp_value_database_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_value_database_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_database_unref (value->data[0].v_pointer);
	}
}


static void icp_value_database_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_database_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_value_database_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_value_database_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpDatabase* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_database_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_value_database_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpDatabase** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_database_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_param_spec_database (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpParamSpecDatabase* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_TYPE_DATABASE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_value_get_database (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_DATABASE), NULL);
	return value->data[0].v_pointer;
}


void icp_value_set_database (GValue* value, gpointer v_object) {
	icpDatabase* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_DATABASE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_DATABASE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_database_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_database_unref (old);
	}
}


void icp_value_take_database (GValue* value, gpointer v_object) {
	icpDatabase* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_DATABASE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_DATABASE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_database_unref (old);
	}
}


static void icp_database_class_init (icpDatabaseClass * klass) {
	icp_database_parent_class = g_type_class_peek_parent (klass);
	ICP_DATABASE_CLASS (klass)->finalize = icp_database_finalize;
	g_type_class_add_private (klass, sizeof (icpDatabasePrivate));
}


static void icp_database_instance_init (icpDatabase * self) {
	self->priv = ICP_DATABASE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void icp_database_finalize (icpDatabase* obj) {
	icpDatabase * self;
	self = ICP_DATABASE (obj);
}


GType icp_database_get_type (void) {
	static volatile gsize icp_database_type_id__volatile = 0;
	if (g_once_init_enter (&icp_database_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_value_database_init, icp_value_database_free_value, icp_value_database_copy_value, icp_value_database_peek_pointer, "p", icp_value_database_collect_value, "p", icp_value_database_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpDatabaseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_database_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpDatabase), 0, (GInstanceInitFunc) icp_database_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_database_type_id;
		icp_database_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpDatabase", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_database_type_id__volatile, icp_database_type_id);
	}
	return icp_database_type_id__volatile;
}


gpointer icp_database_ref (gpointer instance) {
	icpDatabase* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_database_unref (gpointer instance) {
	icpDatabase* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_DATABASE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




