/* dbus-binding.c generated by valac 0.10.4, the Vala compiler
 * generated from dbus-binding.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <dbus/dbus-glib-lowlevel.h>
#include <dbus/dbus-glib.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <dbus/dbus.h>
#include <stdio.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define ICP_TYPE_DBUS_BINDING (icp_dbus_binding_get_type ())
#define ICP_DBUS_BINDING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_TYPE_DBUS_BINDING, icpDBusBinding))
#define ICP_DBUS_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_TYPE_DBUS_BINDING, icpDBusBindingClass))
#define ICP_IS_DBUS_BINDING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_TYPE_DBUS_BINDING))
#define ICP_IS_DBUS_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_TYPE_DBUS_BINDING))
#define ICP_DBUS_BINDING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_TYPE_DBUS_BINDING, icpDBusBindingClass))

typedef struct _icpDBusBinding icpDBusBinding;
typedef struct _icpDBusBindingClass icpDBusBindingClass;
typedef struct _icpDBusBindingPrivate icpDBusBindingPrivate;

#define ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN (icp_dbus_binding_cloud_pinyin_get_type ())
#define ICP_DBUS_BINDING_CLOUD_PINYIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN, icpDBusBindingCloudPinyin))
#define ICP_DBUS_BINDING_CLOUD_PINYIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN, icpDBusBindingCloudPinyinClass))
#define ICP_DBUS_BINDING_IS_CLOUD_PINYIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN))
#define ICP_DBUS_BINDING_IS_CLOUD_PINYIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN))
#define ICP_DBUS_BINDING_CLOUD_PINYIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN, icpDBusBindingCloudPinyinClass))

typedef struct _icpDBusBindingCloudPinyin icpDBusBindingCloudPinyin;
typedef struct _icpDBusBindingCloudPinyinClass icpDBusBindingCloudPinyinClass;

#define ICP_DBUS_BINDING_TYPE_RESPONSE (icp_dbus_binding_response_get_type ())
#define ICP_DBUS_BINDING_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_DBUS_BINDING_TYPE_RESPONSE, icpDBusBindingResponse))
#define ICP_DBUS_BINDING_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_DBUS_BINDING_TYPE_RESPONSE, icpDBusBindingResponseClass))
#define ICP_DBUS_BINDING_IS_RESPONSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_DBUS_BINDING_TYPE_RESPONSE))
#define ICP_DBUS_BINDING_IS_RESPONSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_DBUS_BINDING_TYPE_RESPONSE))
#define ICP_DBUS_BINDING_RESPONSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_DBUS_BINDING_TYPE_RESPONSE, icpDBusBindingResponseClass))

typedef struct _icpDBusBindingResponse icpDBusBindingResponse;
typedef struct _icpDBusBindingResponseClass icpDBusBindingResponseClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _icp_dbus_binding_response_unref0(var) ((var == NULL) ? NULL : (var = (icp_dbus_binding_response_unref (var), NULL)))

#define ICP_PINYIN_TYPE_SEQUENCE (icp_pinyin_sequence_get_type ())
#define ICP_PINYIN_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequence))
#define ICP_PINYIN_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequenceClass))
#define ICP_PINYIN_IS_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_PINYIN_TYPE_SEQUENCE))
#define ICP_PINYIN_IS_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_PINYIN_TYPE_SEQUENCE))
#define ICP_PINYIN_SEQUENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequenceClass))

typedef struct _icpPinyinSequence icpPinyinSequence;
typedef struct _icpPinyinSequenceClass icpPinyinSequenceClass;
#define _icp_pinyin_sequence_unref0(var) ((var == NULL) ? NULL : (var = (icp_pinyin_sequence_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _dbus_g_connection_unref0(var) ((var == NULL) ? NULL : (var = (dbus_g_connection_unref (var), NULL)))
typedef struct _DBusObjectVTable _DBusObjectVTable;
typedef struct _icpDBusBindingResponsePrivate icpDBusBindingResponsePrivate;
typedef struct _icpDBusBindingParamSpecResponse icpDBusBindingParamSpecResponse;

#define ICP_DBUS_BINDING_TYPE_SCEL_TOOL (icp_dbus_binding_scel_tool_get_type ())
#define ICP_DBUS_BINDING_SCEL_TOOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_DBUS_BINDING_TYPE_SCEL_TOOL, icpDBusBindingScelTool))
#define ICP_DBUS_BINDING_SCEL_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_DBUS_BINDING_TYPE_SCEL_TOOL, icpDBusBindingScelToolClass))
#define ICP_DBUS_BINDING_IS_SCEL_TOOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_DBUS_BINDING_TYPE_SCEL_TOOL))
#define ICP_DBUS_BINDING_IS_SCEL_TOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_DBUS_BINDING_TYPE_SCEL_TOOL))
#define ICP_DBUS_BINDING_SCEL_TOOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_DBUS_BINDING_TYPE_SCEL_TOOL, icpDBusBindingScelToolClass))

typedef struct _icpDBusBindingScelTool icpDBusBindingScelTool;
typedef struct _icpDBusBindingScelToolClass icpDBusBindingScelToolClass;
typedef struct _icpDBusBindingScelToolPrivate icpDBusBindingScelToolPrivate;
#define _g_source_unref0(var) ((var == NULL) ? NULL : (var = (g_source_unref (var), NULL)))

#define ICP_PINYIN_TYPE_ID (icp_pinyin_id_get_type ())
#define ICP_PINYIN_ID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_PINYIN_TYPE_ID, icpPinyinId))
#define ICP_PINYIN_ID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_PINYIN_TYPE_ID, icpPinyinIdClass))
#define ICP_PINYIN_IS_ID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_PINYIN_TYPE_ID))
#define ICP_PINYIN_IS_ID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_PINYIN_TYPE_ID))
#define ICP_PINYIN_ID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_PINYIN_TYPE_ID, icpPinyinIdClass))

typedef struct _icpPinyinId icpPinyinId;
typedef struct _icpPinyinIdClass icpPinyinIdClass;
#define _icp_pinyin_id_unref0(var) ((var == NULL) ? NULL : (var = (icp_pinyin_id_unref (var), NULL)))
#define _g_checksum_free0(var) ((var == NULL) ? NULL : (var = (g_checksum_free (var), NULL)))
typedef struct _icpDBusBindingParamSpecScelTool icpDBusBindingParamSpecScelTool;
typedef struct _icpDBusBindingCloudPinyinPrivate icpDBusBindingCloudPinyinPrivate;
typedef struct _icpParamSpecDBusBinding icpParamSpecDBusBinding;

typedef enum  {
	ICP_IO_ERROR_NO_MORE_CONTENT
} icpIOError;
#define ICP_IO_ERROR icp_io_error_quark ()
struct _icpDBusBinding {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpDBusBindingPrivate * priv;
};

struct _icpDBusBindingClass {
	GTypeClass parent_class;
	void (*finalize) (icpDBusBinding *self);
};

struct _DBusObjectVTable {
	void (*register_object) (DBusConnection*, const char*, void*);
};

struct _icpDBusBindingResponse {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpDBusBindingResponsePrivate * priv;
};

struct _icpDBusBindingResponseClass {
	GTypeClass parent_class;
	void (*finalize) (icpDBusBindingResponse *self);
};

struct _icpDBusBindingResponsePrivate {
	char* _content;
	gint _priority;
};

struct _icpDBusBindingParamSpecResponse {
	GParamSpec parent_instance;
};

struct _icpDBusBindingScelTool {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpDBusBindingScelToolPrivate * priv;
};

struct _icpDBusBindingScelToolClass {
	GTypeClass parent_class;
	void (*finalize) (icpDBusBindingScelTool *self);
};

struct _icpDBusBindingParamSpecScelTool {
	GParamSpec parent_instance;
};

struct _icpDBusBindingCloudPinyin {
	GObject parent_instance;
	icpDBusBindingCloudPinyinPrivate * priv;
};

struct _icpDBusBindingCloudPinyinClass {
	GObjectClass parent_class;
};

struct _icpParamSpecDBusBinding {
	GParamSpec parent_instance;
};


static DBusGConnection* icp_dbus_binding_conn;
static DBusGConnection* icp_dbus_binding_conn = NULL;
static DBusGProxy* icp_dbus_binding_bus;
static DBusGProxy* icp_dbus_binding_bus = NULL;
static icpDBusBindingCloudPinyin* icp_dbus_binding_server;
static icpDBusBindingCloudPinyin* icp_dbus_binding_server = NULL;
static gint icp_dbus_binding_last_cloud_length;
static gint icp_dbus_binding_last_cloud_length = 0;
static GeeHashMap* icp_dbus_binding_responses;
static GeeHashMap* icp_dbus_binding_responses = NULL;
static gpointer icp_dbus_binding_response_parent_class = NULL;
static GeeArrayList* icp_dbus_binding_scel_tool_pinyin_list;
static GeeArrayList* icp_dbus_binding_scel_tool_pinyin_list = NULL;
static GeeArrayList* icp_dbus_binding_scel_tool_phrase_list;
static GeeArrayList* icp_dbus_binding_scel_tool_phrase_list = NULL;
static GeeArrayList* icp_dbus_binding_scel_tool_freq_list;
static GeeArrayList* icp_dbus_binding_scel_tool_freq_list = NULL;
static GSource* icp_dbus_binding_scel_tool_idle;
static GSource* icp_dbus_binding_scel_tool_idle = NULL;
static gint icp_dbus_binding_scel_tool_process_index;
static gint icp_dbus_binding_scel_tool_process_index = 0;
extern GMainLoop* icp_main_loop;
static gpointer icp_dbus_binding_scel_tool_parent_class = NULL;
static gpointer icp_dbus_binding_cloud_pinyin_parent_class = NULL;
static gpointer icp_dbus_binding_parent_class = NULL;

GQuark icp_io_error_quark (void);
gpointer icp_dbus_binding_ref (gpointer instance);
void icp_dbus_binding_unref (gpointer instance);
GParamSpec* icp_param_spec_dbus_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_value_set_dbus_binding (GValue* value, gpointer v_object);
void icp_value_take_dbus_binding (GValue* value, gpointer v_object);
gpointer icp_value_get_dbus_binding (const GValue* value);
GType icp_dbus_binding_get_type (void) G_GNUC_CONST;
enum  {
	ICP_DBUS_BINDING_DUMMY_PROPERTY
};
GType icp_dbus_binding_cloud_pinyin_get_type (void) G_GNUC_CONST;
static gpointer icp_dbus_binding_response_ref (gpointer instance);
static void icp_dbus_binding_response_unref (gpointer instance);
static GParamSpec* icp_dbus_binding_param_spec_response (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void icp_dbus_binding_value_set_response (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void icp_dbus_binding_value_take_response (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer icp_dbus_binding_value_get_response (const GValue* value) G_GNUC_UNUSED;
static GType icp_dbus_binding_response_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
char* icp_dbus_binding_query (const char* pinyins);
static const char* icp_dbus_binding_response_get_content (icpDBusBindingResponse* self);
gboolean icp_dbus_binding_set_response (const char* pinyins, const char* content, gint priority);
static gint icp_dbus_binding_response_get_priority (icpDBusBindingResponse* self);
icpPinyinSequence* icp_pinyin_sequence_new (const char* pinyins);
icpPinyinSequence* icp_pinyin_sequence_construct (GType object_type, const char* pinyins);
gpointer icp_pinyin_sequence_ref (gpointer instance);
void icp_pinyin_sequence_unref (gpointer instance);
GParamSpec* icp_pinyin_param_spec_sequence (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_pinyin_value_set_sequence (GValue* value, gpointer v_object);
void icp_pinyin_value_take_sequence (GValue* value, gpointer v_object);
gpointer icp_pinyin_value_get_sequence (const GValue* value);
GType icp_pinyin_sequence_get_type (void) G_GNUC_CONST;
gint icp_pinyin_sequence_get_size (icpPinyinSequence* self);
static icpDBusBindingResponse* icp_dbus_binding_response_new (const char* content, gint priority);
static icpDBusBindingResponse* icp_dbus_binding_response_construct (GType object_type, const char* content, gint priority);
char* icp_dbus_binding_convert (icpPinyinSequence* pinyins, gboolean offline_mode, gint* cloud_length);
char* icp_pinyin_sequence_to_string (icpPinyinSequence* self, gint start, gint len);
char* icp_database_greedy_convert (icpPinyinSequence* pinyins, double phrase_adjust);
icpPinyinSequence* icp_pinyin_sequence_new_copy (icpPinyinSequence* that, gint start, gint len);
icpPinyinSequence* icp_pinyin_sequence_construct_copy (GType object_type, icpPinyinSequence* that, gint start, gint len);
void icp_dbus_binding_init (void);
static guint _dynamic_request_name0 (DBusGProxy* self, const char* param1, guint param2, GError** error);
icpDBusBindingCloudPinyin* icp_dbus_binding_cloud_pinyin_new (void);
icpDBusBindingCloudPinyin* icp_dbus_binding_cloud_pinyin_construct (GType object_type);
static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object);
static void _vala_dbus_unregister_object (gpointer connection, GObject* object);
void icp_dbus_binding_scel_tool_init (void);
icpDBusBinding* icp_dbus_binding_new (void);
icpDBusBinding* icp_dbus_binding_construct (GType object_type);
#define ICP_DBUS_BINDING_RESPONSE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_DBUS_BINDING_TYPE_RESPONSE, icpDBusBindingResponsePrivate))
enum  {
	ICP_DBUS_BINDING_RESPONSE_DUMMY_PROPERTY
};
static void icp_dbus_binding_response_set_content (icpDBusBindingResponse* self, const char* value);
static void icp_dbus_binding_response_set_priority (icpDBusBindingResponse* self, gint value);
static void icp_dbus_binding_response_finalize (icpDBusBindingResponse* obj);
gpointer icp_dbus_binding_scel_tool_ref (gpointer instance);
void icp_dbus_binding_scel_tool_unref (gpointer instance);
GParamSpec* icp_dbus_binding_param_spec_scel_tool (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_dbus_binding_value_set_scel_tool (GValue* value, gpointer v_object);
void icp_dbus_binding_value_take_scel_tool (GValue* value, gpointer v_object);
gpointer icp_dbus_binding_value_get_scel_tool (const GValue* value);
GType icp_dbus_binding_scel_tool_get_type (void) G_GNUC_CONST;
enum  {
	ICP_DBUS_BINDING_SCEL_TOOL_DUMMY_PROPERTY
};
static icpDBusBindingScelTool* icp_dbus_binding_scel_tool_new (void);
static icpDBusBindingScelTool* icp_dbus_binding_scel_tool_construct (GType object_type);
static void icp_dbus_binding_scel_tool_set_idle_source (void);
static gboolean _lambda2_ (void);
static double* _double_dup (double* self);
void icp_database_batch_insert (GeeArrayList* phrases, GeeArrayList* sequences, GeeArrayList* freqs);
void icp_frontend_notify (const char* title, const char* content, const char* icon);
const char* icp_config_get_program_main_icon (void);
static gboolean __lambda2__gsource_func (gpointer self);
void icp_dbus_binding_scel_tool_import (const char* filename);
static gboolean icp_dbus_binding_scel_tool_check_segment_md5 (GFileInputStream* fs, gint64 offset, gsize size, const char* md5);
static char* icp_dbus_binding_scel_tool_read_utf16_segment (GFileInputStream* fs, gint64 offset, gsize size, GError** error);
gpointer icp_pinyin_id_ref (gpointer instance);
void icp_pinyin_id_unref (gpointer instance);
GParamSpec* icp_pinyin_param_spec_id (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_pinyin_value_set_id (GValue* value, gpointer v_object);
void icp_pinyin_value_take_id (GValue* value, gpointer v_object);
gpointer icp_pinyin_value_get_id (const GValue* value);
GType icp_pinyin_id_get_type (void) G_GNUC_CONST;
icpPinyinId* icp_pinyin_id_new (const char* pinyin);
icpPinyinId* icp_pinyin_id_construct (GType object_type, const char* pinyin);
static guint16 icp_dbus_binding_scel_tool_read_uint16 (GFileInputStream* fs, GError** error);
icpPinyinSequence* icp_pinyin_sequence_new_ids (GeeArrayList* ids);
icpPinyinSequence* icp_pinyin_sequence_construct_ids (GType object_type, GeeArrayList* ids);
static void icp_dbus_binding_scel_tool_finalize (icpDBusBindingScelTool* obj);
enum  {
	ICP_DBUS_BINDING_CLOUD_PINYIN_DUMMY_PROPERTY
};
gboolean icp_dbus_binding_cloud_pinyin_cloud_set_response (icpDBusBindingCloudPinyin* self, const char* pinyins, const char* content, gint priority);
char* icp_dbus_binding_cloud_pinyin_cloud_try_query (icpDBusBindingCloudPinyin* self, const char* pinyins);
char* icp_dbus_binding_cloud_pinyin_convert (icpDBusBindingCloudPinyin* self, const char* pinyins);
void icp_dbus_binding_cloud_pinyin_local_remember_phrase (icpDBusBindingCloudPinyin* self, const char* phrase);
gboolean icp_database_reverse_convert (const char* content, icpPinyinSequence** pinyins);
void icp_database_insert (const char* phrase, icpPinyinSequence* sequence, double base_freq, double freq_increase, gboolean lookup_first);
char* icp_dbus_binding_cloud_pinyin_local_reverse_convert (icpDBusBindingCloudPinyin* self, const char* content);
void icp_dbus_binding_cloud_pinyin_import_scel (icpDBusBindingCloudPinyin* self, const char* filename);
void icp_dbus_binding_cloud_pinyin_dbus_register_object (DBusConnection* connection, const char* path, void* object);
void _icp_dbus_binding_cloud_pinyin_dbus_unregister (DBusConnection* connection, void* _user_data_);
DBusHandlerResult icp_dbus_binding_cloud_pinyin_dbus_message (DBusConnection* connection, DBusMessage* message, void* object);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_introspect (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_property_get_all (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_cloud_set_response (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_cloud_try_query (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_convert (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_local_remember_phrase (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_local_reverse_convert (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_import_scel (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message);
static void icp_dbus_binding_finalize (icpDBusBinding* obj);
static int _vala_strcmp0 (const char * str1, const char * str2);

static const DBusObjectPathVTable _icp_dbus_binding_cloud_pinyin_dbus_path_vtable = {_icp_dbus_binding_cloud_pinyin_dbus_unregister, icp_dbus_binding_cloud_pinyin_dbus_message};
static const _DBusObjectVTable _icp_dbus_binding_cloud_pinyin_dbus_vtable = {icp_dbus_binding_cloud_pinyin_dbus_register_object};


GQuark icp_io_error_quark (void) {
	return g_quark_from_static_string ("icp_io_error-quark");
}


static char* string_replace (const char* self, const char* old, const char* replacement) {
	char* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		char* _tmp0_;
		GRegex* _tmp1_;
		GRegex* regex;
		char* _tmp2_;
		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp2_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_assert_not_reached ();
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


char* icp_dbus_binding_query (const char* pinyins) {
	char* result = NULL;
	char* pinyins_u;
	g_return_val_if_fail (pinyins != NULL, NULL);
	pinyins_u = string_replace (pinyins, "v", "ü");
	if (gee_abstract_map_has_key (GEE_ABSTRACT_MAP (icp_dbus_binding_responses), pinyins_u)) {
		icpDBusBindingResponse* _tmp0_;
		char* _tmp1_;
		result = (_tmp1_ = g_strdup (icp_dbus_binding_response_get_content (_tmp0_ = (icpDBusBindingResponse*) gee_abstract_map_get (GEE_ABSTRACT_MAP (icp_dbus_binding_responses), pinyins_u))), _icp_dbus_binding_response_unref0 (_tmp0_), _tmp1_);
		_g_free0 (pinyins_u);
		return result;
	} else {
		result = g_strdup ("");
		_g_free0 (pinyins_u);
		return result;
	}
	_g_free0 (pinyins_u);
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


gboolean icp_dbus_binding_set_response (const char* pinyins, const char* content, gint priority) {
	gboolean result = FALSE;
	char* _tmp0_;
	char* _tmp1_;
	char* pinyins_u;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (pinyins != NULL, FALSE);
	g_return_val_if_fail (content != NULL, FALSE);
	pinyins_u = (_tmp1_ = string_replace (_tmp0_ = g_strdup (pinyins), "v", "ü"), _g_free0 (_tmp0_), _tmp1_);
	if (!gee_abstract_map_has_key (GEE_ABSTRACT_MAP (icp_dbus_binding_responses), pinyins_u)) {
		_tmp3_ = TRUE;
	} else {
		icpDBusBindingResponse* _tmp4_;
		_tmp3_ = icp_dbus_binding_response_get_priority (_tmp4_ = (icpDBusBindingResponse*) gee_abstract_map_get (GEE_ABSTRACT_MAP (icp_dbus_binding_responses), pinyins_u)) <= priority;
		_icp_dbus_binding_response_unref0 (_tmp4_);
	}
	if (_tmp3_) {
		icpPinyinSequence* _tmp5_;
		_tmp2_ = icp_pinyin_sequence_get_size (_tmp5_ = icp_pinyin_sequence_new (pinyins_u)) == string_get_length (content);
		_icp_pinyin_sequence_unref0 (_tmp5_);
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		icpDBusBindingResponse* _tmp6_;
		gee_abstract_map_set (GEE_ABSTRACT_MAP (icp_dbus_binding_responses), pinyins_u, _tmp6_ = icp_dbus_binding_response_new (content, priority));
		_icp_dbus_binding_response_unref0 (_tmp6_);
		result = TRUE;
		_g_free0 (pinyins_u);
		return result;
	}
	result = FALSE;
	_g_free0 (pinyins_u);
	return result;
}


char* icp_dbus_binding_convert (icpPinyinSequence* pinyins, gboolean offline_mode, gint* cloud_length) {
	char* result = NULL;
	g_return_val_if_fail (ICP_PINYIN_IS_SEQUENCE (pinyins), NULL);
	if (!offline_mode) {
		{
			gint i;
			i = icp_pinyin_sequence_get_size (pinyins);
			{
				gboolean _tmp0_;
				_tmp0_ = TRUE;
				while (TRUE) {
					char* _tmp1_;
					char* _tmp2_;
					char* _result_;
					if (!_tmp0_) {
						i--;
					}
					_tmp0_ = FALSE;
					if (!(i > 0)) {
						break;
					}
					_result_ = (_tmp2_ = icp_dbus_binding_query (_tmp1_ = icp_pinyin_sequence_to_string (pinyins, 0, i)), _g_free0 (_tmp1_), _tmp2_);
					if (strlen (_result_) > 0) {
						icpPinyinSequence* _tmp3_;
						char* _tmp4_;
						char* _tmp5_;
						*cloud_length = (gint) string_get_length (_result_);
						result = (_tmp5_ = g_strconcat (_result_, _tmp4_ = icp_database_greedy_convert (_tmp3_ = icp_pinyin_sequence_new_copy (pinyins, i, -1), 2), NULL), _g_free0 (_tmp4_), _icp_pinyin_sequence_unref0 (_tmp3_), _tmp5_);
						_g_free0 (_result_);
						return result;
					}
					_g_free0 (_result_);
				}
			}
		}
	}
	*cloud_length = 0;
	result = icp_database_greedy_convert (pinyins, 2);
	return result;
}


static guint _dynamic_request_name0 (DBusGProxy* self, const char* param1, guint param2, GError** error) {
	guint result;
	dbus_g_proxy_call (self, "RequestName", error, G_TYPE_STRING, param1, G_TYPE_UINT, param2, G_TYPE_INVALID, G_TYPE_UINT, &result, G_TYPE_INVALID);
	if (*error) {
		return 0U;
	}
	return result;
}


static void _vala_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	const _DBusObjectVTable * vtable;
	vtable = g_type_get_qdata (G_TYPE_FROM_INSTANCE (object), g_quark_from_static_string ("DBusObjectVTable"));
	if (vtable) {
		vtable->register_object (connection, path, object);
	} else {
		g_warning ("Object does not implement any D-Bus interface");
	}
}


static void _vala_dbus_unregister_object (gpointer connection, GObject* object) {
	char* path;
	path = g_object_steal_data ((GObject*) object, "dbus_object_path");
	dbus_connection_unregister_object_path (connection, path);
	g_free (path);
}


void icp_dbus_binding_init (void) {
	GeeHashMap* _tmp0_;
	GError * _inner_error_ = NULL;
	icp_dbus_binding_responses = (_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, ICP_DBUS_BINDING_TYPE_RESPONSE, (GBoxedCopyFunc) icp_dbus_binding_response_ref, icp_dbus_binding_response_unref, NULL, NULL, NULL), _g_object_unref0 (icp_dbus_binding_responses), _tmp0_);
	{
		DBusGConnection* _tmp1_;
		DBusGConnection* _tmp2_;
		DBusGProxy* _tmp3_;
		guint request_name_result;
		_tmp1_ = dbus_g_bus_get (DBUS_BUS_SESSION, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		icp_dbus_binding_conn = (_tmp2_ = _tmp1_, _dbus_g_connection_unref0 (icp_dbus_binding_conn), _tmp2_);
		icp_dbus_binding_bus = (_tmp3_ = dbus_g_proxy_new_for_name (icp_dbus_binding_conn, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus"), _g_object_unref0 (icp_dbus_binding_bus), _tmp3_);
		request_name_result = _dynamic_request_name0 (icp_dbus_binding_bus, "org.ibus.CloudPinyin", (guint) 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		if (request_name_result == DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
			icpDBusBindingCloudPinyin* _tmp4_;
			icp_dbus_binding_server = (_tmp4_ = icp_dbus_binding_cloud_pinyin_new (), _g_object_unref0 (icp_dbus_binding_server), _tmp4_);
			_vala_dbus_register_object (dbus_g_connection_get_connection (icp_dbus_binding_conn), "/org/ibus/CloudPinyin", G_OBJECT (icp_dbus_binding_server));
		} else {
			fprintf (stderr, "%s", "FATAL: register DBus fail!\n" "Please do not run this program multi times manually.\n");
			g_assert_not_reached ();
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "Error: %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	icp_dbus_binding_scel_tool_init ();
}


icpDBusBinding* icp_dbus_binding_construct (GType object_type) {
	icpDBusBinding* self = (icpDBusBinding*) g_type_create_instance (object_type);
	return self;
}


icpDBusBinding* icp_dbus_binding_new (void) {
	return icp_dbus_binding_construct (ICP_TYPE_DBUS_BINDING);
}


static icpDBusBindingResponse* icp_dbus_binding_response_construct (GType object_type, const char* content, gint priority) {
	icpDBusBindingResponse* self = (icpDBusBindingResponse*) g_type_create_instance (object_type);
	g_return_val_if_fail (content != NULL, NULL);
	icp_dbus_binding_response_set_content (self, content);
	icp_dbus_binding_response_set_priority (self, priority);
	return self;
}


static icpDBusBindingResponse* icp_dbus_binding_response_new (const char* content, gint priority) {
	return icp_dbus_binding_response_construct (ICP_DBUS_BINDING_TYPE_RESPONSE, content, priority);
}


static const char* icp_dbus_binding_response_get_content (icpDBusBindingResponse* self) {
	const char* result;
	g_return_val_if_fail (ICP_DBUS_BINDING_IS_RESPONSE (self), NULL);
	result = self->priv->_content;
	return result;
}


static void icp_dbus_binding_response_set_content (icpDBusBindingResponse* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (ICP_DBUS_BINDING_IS_RESPONSE (self));
	self->priv->_content = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_content), _tmp0_);
}


static gint icp_dbus_binding_response_get_priority (icpDBusBindingResponse* self) {
	gint result;
	g_return_val_if_fail (ICP_DBUS_BINDING_IS_RESPONSE (self), 0);
	result = self->priv->_priority;
	return result;
}


static void icp_dbus_binding_response_set_priority (icpDBusBindingResponse* self, gint value) {
	g_return_if_fail (ICP_DBUS_BINDING_IS_RESPONSE (self));
	self->priv->_priority = value;
}


static void icp_dbus_binding_value_response_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_dbus_binding_value_response_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_dbus_binding_response_unref (value->data[0].v_pointer);
	}
}


static void icp_dbus_binding_value_response_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_dbus_binding_response_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_dbus_binding_value_response_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_dbus_binding_value_response_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpDBusBindingResponse* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_dbus_binding_response_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_dbus_binding_value_response_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpDBusBindingResponse** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_dbus_binding_response_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* icp_dbus_binding_param_spec_response (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpDBusBindingParamSpecResponse* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_DBUS_BINDING_TYPE_RESPONSE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer icp_dbus_binding_value_get_response (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_DBUS_BINDING_TYPE_RESPONSE), NULL);
	return value->data[0].v_pointer;
}


static void icp_dbus_binding_value_set_response (GValue* value, gpointer v_object) {
	icpDBusBindingResponse* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_DBUS_BINDING_TYPE_RESPONSE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_DBUS_BINDING_TYPE_RESPONSE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_dbus_binding_response_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_dbus_binding_response_unref (old);
	}
}


static void icp_dbus_binding_value_take_response (GValue* value, gpointer v_object) {
	icpDBusBindingResponse* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_DBUS_BINDING_TYPE_RESPONSE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_DBUS_BINDING_TYPE_RESPONSE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_dbus_binding_response_unref (old);
	}
}


static void icp_dbus_binding_response_class_init (icpDBusBindingResponseClass * klass) {
	icp_dbus_binding_response_parent_class = g_type_class_peek_parent (klass);
	ICP_DBUS_BINDING_RESPONSE_CLASS (klass)->finalize = icp_dbus_binding_response_finalize;
	g_type_class_add_private (klass, sizeof (icpDBusBindingResponsePrivate));
}


static void icp_dbus_binding_response_instance_init (icpDBusBindingResponse * self) {
	self->priv = ICP_DBUS_BINDING_RESPONSE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void icp_dbus_binding_response_finalize (icpDBusBindingResponse* obj) {
	icpDBusBindingResponse * self;
	self = ICP_DBUS_BINDING_RESPONSE (obj);
	_g_free0 (self->priv->_content);
}


static GType icp_dbus_binding_response_get_type (void) {
	static volatile gsize icp_dbus_binding_response_type_id__volatile = 0;
	if (g_once_init_enter (&icp_dbus_binding_response_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_dbus_binding_value_response_init, icp_dbus_binding_value_response_free_value, icp_dbus_binding_value_response_copy_value, icp_dbus_binding_value_response_peek_pointer, "p", icp_dbus_binding_value_response_collect_value, "p", icp_dbus_binding_value_response_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpDBusBindingResponseClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_dbus_binding_response_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpDBusBindingResponse), 0, (GInstanceInitFunc) icp_dbus_binding_response_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_dbus_binding_response_type_id;
		icp_dbus_binding_response_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpDBusBindingResponse", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_dbus_binding_response_type_id__volatile, icp_dbus_binding_response_type_id);
	}
	return icp_dbus_binding_response_type_id__volatile;
}


static gpointer icp_dbus_binding_response_ref (gpointer instance) {
	icpDBusBindingResponse* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void icp_dbus_binding_response_unref (gpointer instance) {
	icpDBusBindingResponse* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_DBUS_BINDING_RESPONSE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static icpDBusBindingScelTool* icp_dbus_binding_scel_tool_construct (GType object_type) {
	icpDBusBindingScelTool* self = (icpDBusBindingScelTool*) g_type_create_instance (object_type);
	return self;
}


static icpDBusBindingScelTool* icp_dbus_binding_scel_tool_new (void) {
	return icp_dbus_binding_scel_tool_construct (ICP_DBUS_BINDING_TYPE_SCEL_TOOL);
}


static double* _double_dup (double* self) {
	double* dup;
	dup = g_new0 (double, 1);
	memcpy (dup, self, sizeof (double));
	return dup;
}


static gboolean _lambda2_ (void) {
	gboolean result = FALSE;
	GeeArrayList* sequences;
	GeeArrayList* phrases;
	GeeArrayList* freqs;
	sequences = gee_array_list_new (ICP_PINYIN_TYPE_SEQUENCE, (GBoxedCopyFunc) icp_pinyin_sequence_ref, icp_pinyin_sequence_unref, NULL);
	phrases = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	freqs = gee_array_list_new (G_TYPE_DOUBLE, (GBoxedCopyFunc) _double_dup, g_free, NULL);
	{
		gint import_count;
		import_count = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				double* _tmp2_;
				double _tmp3_;
				double freq;
				if (!_tmp0_) {
					icp_dbus_binding_scel_tool_process_index++;
				}
				_tmp0_ = FALSE;
				if (import_count < 2048) {
					_tmp1_ = icp_dbus_binding_scel_tool_process_index < gee_collection_get_size (GEE_COLLECTION (icp_dbus_binding_scel_tool_pinyin_list));
				} else {
					_tmp1_ = FALSE;
				}
				if (!_tmp1_) {
					break;
				}
				freq = (_tmp3_ = *(_tmp2_ = (double*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_dbus_binding_scel_tool_freq_list), icp_dbus_binding_scel_tool_process_index)), _g_free0 (_tmp2_), _tmp3_);
				if (freq > 10) {
					icpPinyinSequence* _tmp4_;
					char* _tmp5_;
					gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (sequences), _tmp4_ = (icpPinyinSequence*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_dbus_binding_scel_tool_pinyin_list), icp_dbus_binding_scel_tool_process_index));
					_icp_pinyin_sequence_unref0 (_tmp4_);
					gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (phrases), _tmp5_ = (char*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_dbus_binding_scel_tool_phrase_list), icp_dbus_binding_scel_tool_process_index));
					_g_free0 (_tmp5_);
					gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (freqs), &freq);
					import_count++;
				}
			}
		}
	}
	icp_database_batch_insert (phrases, sequences, freqs);
	if (icp_dbus_binding_scel_tool_process_index >= gee_collection_get_size (GEE_COLLECTION (icp_dbus_binding_scel_tool_pinyin_list))) {
		GSource* _tmp6_;
		icp_frontend_notify ("导入 scel 词库", "导入已完成", icp_config_get_program_main_icon ());
		gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (icp_dbus_binding_scel_tool_pinyin_list));
		gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (icp_dbus_binding_scel_tool_phrase_list));
		gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (icp_dbus_binding_scel_tool_freq_list));
		icp_dbus_binding_scel_tool_process_index = 0;
		icp_dbus_binding_scel_tool_idle = (_tmp6_ = NULL, _g_source_unref0 (icp_dbus_binding_scel_tool_idle), _tmp6_);
		result = FALSE;
		_g_object_unref0 (freqs);
		_g_object_unref0 (phrases);
		_g_object_unref0 (sequences);
		return result;
	}
	result = TRUE;
	_g_object_unref0 (freqs);
	_g_object_unref0 (phrases);
	_g_object_unref0 (sequences);
	return result;
}


static gboolean __lambda2__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda2_ ();
	return result;
}


static void icp_dbus_binding_scel_tool_set_idle_source (void) {
	GSource* _tmp0_;
	if (icp_dbus_binding_scel_tool_idle != NULL) {
		return;
	}
	icp_dbus_binding_scel_tool_process_index = 0;
	icp_dbus_binding_scel_tool_idle = (_tmp0_ = g_idle_source_new (), _g_source_unref0 (icp_dbus_binding_scel_tool_idle), _tmp0_);
	g_source_set_callback (icp_dbus_binding_scel_tool_idle, __lambda2__gsource_func, NULL, NULL);
	g_source_attach (icp_dbus_binding_scel_tool_idle, g_main_loop_get_context (icp_main_loop));
}


void icp_dbus_binding_scel_tool_init (void) {
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GSource* _tmp3_;
	icp_dbus_binding_scel_tool_pinyin_list = (_tmp0_ = gee_array_list_new (ICP_PINYIN_TYPE_SEQUENCE, (GBoxedCopyFunc) icp_pinyin_sequence_ref, icp_pinyin_sequence_unref, NULL), _g_object_unref0 (icp_dbus_binding_scel_tool_pinyin_list), _tmp0_);
	icp_dbus_binding_scel_tool_phrase_list = (_tmp1_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL), _g_object_unref0 (icp_dbus_binding_scel_tool_phrase_list), _tmp1_);
	icp_dbus_binding_scel_tool_freq_list = (_tmp2_ = gee_array_list_new (G_TYPE_DOUBLE, (GBoxedCopyFunc) _double_dup, g_free, NULL), _g_object_unref0 (icp_dbus_binding_scel_tool_freq_list), _tmp2_);
	icp_dbus_binding_scel_tool_idle = (_tmp3_ = NULL, _g_source_unref0 (icp_dbus_binding_scel_tool_idle), _tmp3_);
}


void icp_dbus_binding_scel_tool_import (const char* filename) {
	GFile* file;
	GFileInputStream* fs;
	char* title;
	char* type;
	char* description;
	char* examples;
	GeeHashMap* pinyin_map;
	double max_freq;
	double all_freq;
	gint phrase_count;
	GError * _inner_error_ = NULL;
	g_return_if_fail (filename != NULL);
	file = NULL;
	fs = NULL;
	{
		GFile* _tmp0_;
		GFileInputStream* _tmp1_;
		GFileInputStream* _tmp2_;
		gboolean _tmp3_ = FALSE;
		file = (_tmp0_ = g_file_new_for_path (filename), _g_object_unref0 (file), _tmp0_);
		_tmp1_ = g_file_read (file, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
		fs = (_tmp2_ = _tmp1_, _g_object_unref0 (fs), _tmp2_);
		if (!icp_dbus_binding_scel_tool_check_segment_md5 (fs, (gint64) 0, (gsize) 9, "053950cf925005c1f875bd5a3ab70399")) {
			_tmp3_ = TRUE;
		} else {
			_tmp3_ = !icp_dbus_binding_scel_tool_check_segment_md5 (fs, (gint64) 0x1540, (gsize) 4, "b81f3dd20a5a9956cbcd838e2658cc69");
		}
		if (_tmp3_) {
			icp_frontend_notify ("无法导入 scel 文件", "文件格式不兼容", "error");
			_g_object_unref0 (fs);
			_g_object_unref0 (file);
			return;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			char* _tmp4_;
			icp_frontend_notify ("无法导入 scel 文件", _tmp4_ = g_strdup_printf ("无法访问文件 %s\n%s", filename, e->message), "error");
			_g_free0 (_tmp4_);
			_g_error_free0 (e);
			_g_object_unref0 (fs);
			_g_object_unref0 (file);
			return;
		}
	}
	__finally2:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (fs);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	title = icp_dbus_binding_scel_tool_read_utf16_segment (fs, (gint64) 0x130, (gsize) (0x338 - 0x130), &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (fs);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	type = icp_dbus_binding_scel_tool_read_utf16_segment (fs, (gint64) 0x338, (gsize) (0x540 - 0x338), &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_free0 (title);
		_g_object_unref0 (fs);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	description = icp_dbus_binding_scel_tool_read_utf16_segment (fs, (gint64) 0x540, (gsize) (0xd40 - 0x540), &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_free0 (type);
		_g_free0 (title);
		_g_object_unref0 (fs);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	examples = icp_dbus_binding_scel_tool_read_utf16_segment (fs, (gint64) 0xd40, (gsize) (0x1540 - 0xd40), &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_free0 (description);
		_g_free0 (type);
		_g_free0 (title);
		_g_object_unref0 (fs);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	pinyin_map = gee_hash_map_new (G_TYPE_INT, NULL, NULL, ICP_PINYIN_TYPE_ID, (GBoxedCopyFunc) icp_pinyin_id_ref, icp_pinyin_id_unref, NULL, NULL, NULL);
	G_FILE_INPUT_STREAM_GET_CLASS (fs)->seek (fs, (gint64) (0x1540 + 4), G_SEEK_SET, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		_g_object_unref0 (pinyin_map);
		_g_free0 (examples);
		_g_free0 (description);
		_g_free0 (type);
		_g_free0 (title);
		_g_object_unref0 (fs);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	while (TRUE) {
		gint pinyin_header_length1;
		gint _pinyin_header_size_;
		guint16* _tmp5_;
		guint16* pinyin_header;
		char* pinyin_content;
		const char* _tmp8_;
		GQuark _tmp9_;
		static GQuark _tmp9__label0 = 0;
		static GQuark _tmp9__label1 = 0;
		icpPinyinId* _tmp10_;
		pinyin_header = (_tmp5_ = g_new0 (guint16, 2), pinyin_header_length1 = 2, _pinyin_header_size_ = pinyin_header_length1, _tmp5_);
		g_input_stream_read (G_INPUT_STREAM (fs), (guint8*) pinyin_header, (gsize) 4, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			pinyin_header = (g_free (pinyin_header), NULL);
			_g_object_unref0 (pinyin_map);
			_g_free0 (examples);
			_g_free0 (description);
			_g_free0 (type);
			_g_free0 (title);
			_g_object_unref0 (fs);
			_g_object_unref0 (file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		if (pinyin_header[1] == 0) {
			pinyin_header = (g_free (pinyin_header), NULL);
			break;
		}
		if (gee_abstract_map_has_key (GEE_ABSTRACT_MAP (pinyin_map), GINT_TO_POINTER ((gint) pinyin_header[0]))) {
			pinyin_header = (g_free (pinyin_header), NULL);
			break;
		}
		pinyin_content = icp_dbus_binding_scel_tool_read_utf16_segment (fs, (gint64) (-1), (gsize) pinyin_header[1], &_inner_error_);
		if (_inner_error_ != NULL) {
			pinyin_header = (g_free (pinyin_header), NULL);
			_g_object_unref0 (pinyin_map);
			_g_free0 (examples);
			_g_free0 (description);
			_g_free0 (type);
			_g_free0 (title);
			_g_object_unref0 (fs);
			_g_object_unref0 (file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp8_ = pinyin_content;
		_tmp9_ = (NULL == _tmp8_) ? 0 : g_quark_from_string (_tmp8_);
		if (_tmp9_ == ((0 != _tmp9__label0) ? _tmp9__label0 : (_tmp9__label0 = g_quark_from_static_string ("lue"))))
		switch (0) {
			default:
			{
				char* _tmp6_;
				pinyin_content = (_tmp6_ = g_strdup ("lve"), _g_free0 (pinyin_content), _tmp6_);
				break;
			}
		} else if (_tmp9_ == ((0 != _tmp9__label1) ? _tmp9__label1 : (_tmp9__label1 = g_quark_from_static_string ("nue"))))
		switch (0) {
			default:
			{
				char* _tmp7_;
				pinyin_content = (_tmp7_ = g_strdup ("nve"), _g_free0 (pinyin_content), _tmp7_);
				break;
			}
		}
		gee_abstract_map_set (GEE_ABSTRACT_MAP (pinyin_map), GINT_TO_POINTER ((gint) pinyin_header[0]), _tmp10_ = icp_pinyin_id_new (pinyin_content));
		_icp_pinyin_id_unref0 (_tmp10_);
		_g_free0 (pinyin_content);
		pinyin_header = (g_free (pinyin_header), NULL);
	}
	max_freq = (double) 0;
	all_freq = (double) 0;
	phrase_count = 0;
	{
		G_FILE_INPUT_STREAM_GET_CLASS (fs)->seek (fs, (gint64) 0x2628, G_SEEK_SET, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (g_error_matches (_inner_error_, ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT)) {
				goto __catch3_icp_io_error_no_more_content;
			}
			goto __catch3_g_error;
		}
		while (TRUE) {
			guint16 _tmp11_;
			gint offset;
			guint16 _tmp12_;
			gint pinyin_count;
			GeeArrayList* pinyins;
			gint phrase_len;
			char* phrase;
			gsize freq_len;
			gint freq_data_length1;
			gint _freq_data_size_;
			guint8* _tmp15_;
			guint8* freq_data;
			double freq;
			double freq_base;
			icpPinyinSequence* _tmp17_;
			_tmp11_ = icp_dbus_binding_scel_tool_read_uint16 (fs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (g_error_matches (_inner_error_, ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT)) {
					goto __catch3_icp_io_error_no_more_content;
				}
				goto __catch3_g_error;
			}
			offset = _tmp11_ - 1;
			_tmp12_ = icp_dbus_binding_scel_tool_read_uint16 (fs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (g_error_matches (_inner_error_, ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT)) {
					goto __catch3_icp_io_error_no_more_content;
				}
				goto __catch3_g_error;
			}
			pinyin_count = _tmp12_ / 2;
			pinyins = gee_array_list_new (ICP_PINYIN_TYPE_ID, (GBoxedCopyFunc) icp_pinyin_id_ref, icp_pinyin_id_unref, NULL);
			{
				gint i;
				i = 0;
				{
					gboolean _tmp13_;
					_tmp13_ = TRUE;
					while (TRUE) {
						guint16 pinyin_id;
						icpPinyinId* _tmp14_;
						if (!_tmp13_) {
							i++;
						}
						_tmp13_ = FALSE;
						if (!(i < pinyin_count)) {
							break;
						}
						pinyin_id = icp_dbus_binding_scel_tool_read_uint16 (fs, &_inner_error_);
						if (_inner_error_ != NULL) {
							_g_object_unref0 (pinyins);
							if (g_error_matches (_inner_error_, ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT)) {
								goto __catch3_icp_io_error_no_more_content;
							}
							goto __catch3_g_error;
						}
						gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (pinyins), _tmp14_ = (icpPinyinId*) gee_abstract_map_get (GEE_ABSTRACT_MAP (pinyin_map), GINT_TO_POINTER ((gint) pinyin_id)));
						_icp_pinyin_id_unref0 (_tmp14_);
					}
				}
			}
			phrase_len = (gint) icp_dbus_binding_scel_tool_read_uint16 (fs, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (pinyins);
				if (g_error_matches (_inner_error_, ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT)) {
					goto __catch3_icp_io_error_no_more_content;
				}
				goto __catch3_g_error;
			}
			phrase = icp_dbus_binding_scel_tool_read_utf16_segment (fs, (gint64) (-1), (gsize) phrase_len, &_inner_error_);
			if (_inner_error_ != NULL) {
				_g_object_unref0 (pinyins);
				if (g_error_matches (_inner_error_, ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT)) {
					goto __catch3_icp_io_error_no_more_content;
				}
				goto __catch3_g_error;
			}
			freq_len = (gsize) (12 + (offset * ((12 + (pinyin_count * 2)) + 2)));
			freq_data = (_tmp15_ = g_new0 (guint8, freq_len), freq_data_length1 = freq_len, _freq_data_size_ = freq_data_length1, _tmp15_);
			g_input_stream_read (G_INPUT_STREAM (fs), (guint8*) freq_data, freq_len, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				freq_data = (g_free (freq_data), NULL);
				_g_free0 (phrase);
				_g_object_unref0 (pinyins);
				if (g_error_matches (_inner_error_, ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT)) {
					goto __catch3_icp_io_error_no_more_content;
				}
				goto __catch3_g_error;
			}
			freq = (double) 0;
			freq_base = (double) 1;
			{
				gint i;
				i = 2;
				{
					gboolean _tmp16_;
					_tmp16_ = TRUE;
					while (TRUE) {
						if (!_tmp16_) {
							i++;
						}
						_tmp16_ = FALSE;
						if (!(i <= 3)) {
							break;
						}
						freq = freq + (freq_base * freq_data[i]);
						freq_base = freq_base * ((double) 256);
					}
				}
			}
			gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (icp_dbus_binding_scel_tool_freq_list), &freq);
			gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (icp_dbus_binding_scel_tool_pinyin_list), _tmp17_ = icp_pinyin_sequence_new_ids (pinyins));
			_icp_pinyin_sequence_unref0 (_tmp17_);
			gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (icp_dbus_binding_scel_tool_phrase_list), phrase);
			phrase_count++;
			if (freq > max_freq) {
				max_freq = freq;
			}
			all_freq = all_freq + freq;
			freq_data = (g_free (freq_data), NULL);
			_g_free0 (phrase);
			_g_object_unref0 (pinyins);
		}
	}
	goto __finally3;
	__catch3_icp_io_error_no_more_content:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			double factor;
			gint freq_list_index;
			char* _tmp22_;
			char* _tmp23_;
			factor = 10000.0 / (max_freq + (all_freq / phrase_count));
			freq_list_index = gee_collection_get_size (GEE_COLLECTION (icp_dbus_binding_scel_tool_freq_list));
			{
				gint i;
				i = 0;
				{
					gboolean _tmp18_;
					_tmp18_ = TRUE;
					while (TRUE) {
						double* _tmp19_;
						double _tmp20_;
						double freq;
						double _tmp21_;
						if (!_tmp18_) {
							i++;
						}
						_tmp18_ = FALSE;
						if (!(i < phrase_count)) {
							break;
						}
						if ((freq_list_index = freq_list_index - 1) < 0) {
							break;
						}
						freq = (_tmp20_ = *(_tmp19_ = (double*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_dbus_binding_scel_tool_freq_list), freq_list_index)), _g_free0 (_tmp19_), _tmp20_);
						gee_abstract_list_set (GEE_ABSTRACT_LIST (icp_dbus_binding_scel_tool_freq_list), freq_list_index, (_tmp21_ = freq * factor, &_tmp21_));
					}
				}
			}
			icp_frontend_notify (_tmp22_ = g_strdup_printf ("正在后台导入 scel 词库: %s", title), _tmp23_ = g_strdup_printf ("词条数: %d\n类别: %s\n描述: %s", phrase_count, type, description), icp_config_get_program_main_icon ());
			_g_free0 (_tmp23_);
			_g_free0 (_tmp22_);
			icp_dbus_binding_scel_tool_set_idle_source ();
			_g_error_free0 (e);
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			char* _tmp24_;
			icp_frontend_notify ("无法导入 scel 文件", _tmp24_ = g_strdup_printf ("无法访问文件 %s\n%s", filename, e->message), "error");
			_g_free0 (_tmp24_);
			_g_error_free0 (e);
		}
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (pinyin_map);
		_g_free0 (examples);
		_g_free0 (description);
		_g_free0 (type);
		_g_free0 (title);
		_g_object_unref0 (fs);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (pinyin_map);
	_g_free0 (examples);
	_g_free0 (description);
	_g_free0 (type);
	_g_free0 (title);
	_g_object_unref0 (fs);
	_g_object_unref0 (file);
}


static gboolean icp_dbus_binding_scel_tool_check_segment_md5 (GFileInputStream* fs, gint64 offset, gsize size, const char* md5) {
	gboolean result = FALSE;
	GChecksum* sum;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (G_IS_FILE_INPUT_STREAM (fs), FALSE);
	g_return_val_if_fail (md5 != NULL, FALSE);
	sum = g_checksum_new (G_CHECKSUM_MD5);
	{
		gboolean _tmp0_;
		gint bytes_length1;
		gint _bytes_size_;
		gchar* _tmp1_;
		gchar* bytes;
		gssize _tmp2_;
		_tmp0_ = G_FILE_INPUT_STREAM_GET_CLASS (fs)->seek (fs, offset, G_SEEK_SET, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
		if (!_tmp0_) {
			result = FALSE;
			_g_checksum_free0 (sum);
			return result;
		}
		bytes = (_tmp1_ = g_new0 (gchar, size), bytes_length1 = size, _bytes_size_ = bytes_length1, _tmp1_);
		_tmp2_ = g_input_stream_read (G_INPUT_STREAM (fs), bytes, size, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			bytes = (g_free (bytes), NULL);
			goto __catch4_g_error;
		}
		if (_tmp2_ != size) {
			result = FALSE;
			bytes = (g_free (bytes), NULL);
			_g_checksum_free0 (sum);
			return result;
		}
		g_checksum_update (sum, (guchar*) bytes, size);
		result = _vala_strcmp0 (g_checksum_get_string (sum), md5) == 0;
		bytes = (g_free (bytes), NULL);
		_g_checksum_free0 (sum);
		return result;
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			result = FALSE;
			_g_error_free0 (e);
			_g_checksum_free0 (sum);
			return result;
		}
	}
	__finally4:
	{
		_g_checksum_free0 (sum);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_g_checksum_free0 (sum);
}


static guint16 icp_dbus_binding_scel_tool_read_uint16 (GFileInputStream* fs, GError** error) {
	guint16 result = 0U;
	gint data_length1;
	gint _data_size_;
	guint16* _tmp0_;
	guint16* data;
	gssize _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (G_IS_FILE_INPUT_STREAM (fs), 0U);
	data = (_tmp0_ = g_new0 (guint16, 1), data_length1 = 1, _data_size_ = data_length1, _tmp0_);
	_tmp1_ = g_input_stream_read (G_INPUT_STREAM (fs), (guint8*) data, (gsize) 2, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == ICP_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			data = (g_free (data), NULL);
			return 0U;
		} else {
			data = (g_free (data), NULL);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0U;
		}
	}
	if (_tmp1_ == 0) {
		_inner_error_ = g_error_new_literal (ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT, "read nothing");
		{
			if (_inner_error_->domain == ICP_IO_ERROR) {
				g_propagate_error (error, _inner_error_);
				data = (g_free (data), NULL);
				return 0U;
			} else {
				data = (g_free (data), NULL);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return 0U;
			}
		}
	}
	result = data[0];
	data = (g_free (data), NULL);
	return result;
}


static char* icp_dbus_binding_scel_tool_read_utf16_segment (GFileInputStream* fs, gint64 offset, gsize size, GError** error) {
	char* result = NULL;
	char* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (G_IS_FILE_INPUT_STREAM (fs), NULL);
	_result_ = g_strdup ("");
	{
		gint bytes_length1;
		gint _bytes_size_;
		gchar* _tmp1_;
		gchar* bytes;
		gssize _tmp2_;
		char* _tmp3_;
		char* _tmp4_;
		if (offset > 0) {
			gboolean _tmp0_;
			_tmp0_ = G_FILE_INPUT_STREAM_GET_CLASS (fs)->seek (fs, offset, G_SEEK_SET, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == G_CONVERT_ERROR) {
					goto __catch5_g_convert_error;
				}
				goto __catch5_g_error;
			}
			if (!_tmp0_) {
				result = _result_;
				return result;
			}
		}
		bytes = (_tmp1_ = g_new0 (gchar, size + 1), bytes_length1 = size + 1, _bytes_size_ = bytes_length1, _tmp1_);
		_tmp2_ = g_input_stream_read (G_INPUT_STREAM (fs), bytes, size, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			bytes = (g_free (bytes), NULL);
			if (_inner_error_->domain == G_CONVERT_ERROR) {
				goto __catch5_g_convert_error;
			}
			goto __catch5_g_error;
		}
		if (_tmp2_ != size) {
			_inner_error_ = g_error_new_literal (ICP_IO_ERROR, ICP_IO_ERROR_NO_MORE_CONTENT, "read nothing");
			{
				bytes = (g_free (bytes), NULL);
				if (_inner_error_->domain == G_CONVERT_ERROR) {
					goto __catch5_g_convert_error;
				}
				goto __catch5_g_error;
			}
		}
		bytes[size] = (gchar) 0;
		_tmp3_ = g_convert ((const char*) bytes, (gssize) size, "UTF-8", "UTF-16LE", NULL, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			bytes = (g_free (bytes), NULL);
			if (_inner_error_->domain == G_CONVERT_ERROR) {
				goto __catch5_g_convert_error;
			}
			goto __catch5_g_error;
		}
		_result_ = (_tmp4_ = _tmp3_, _g_free0 (_result_), _tmp4_);
		bytes = (g_free (bytes), NULL);
	}
	goto __finally5;
	__catch5_g_convert_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			char* _tmp5_;
			g_warning ("dbus-binding.vala:303: Encoding convert error in scel file");
			_result_ = (_tmp5_ = g_strdup (""), _g_free0 (_result_), _tmp5_);
			_g_error_free0 (e);
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			char* _tmp6_;
			_result_ = (_tmp6_ = g_strdup (""), _g_free0 (_result_), _tmp6_);
			_g_error_free0 (e);
		}
	}
	__finally5:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == ICP_IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (_result_);
			return NULL;
		} else {
			_g_free0 (_result_);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = _result_;
	return result;
}


static void icp_dbus_binding_value_scel_tool_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_dbus_binding_value_scel_tool_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_dbus_binding_scel_tool_unref (value->data[0].v_pointer);
	}
}


static void icp_dbus_binding_value_scel_tool_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_dbus_binding_scel_tool_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_dbus_binding_value_scel_tool_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_dbus_binding_value_scel_tool_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpDBusBindingScelTool* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_dbus_binding_scel_tool_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_dbus_binding_value_scel_tool_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpDBusBindingScelTool** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_dbus_binding_scel_tool_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_dbus_binding_param_spec_scel_tool (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpDBusBindingParamSpecScelTool* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_DBUS_BINDING_TYPE_SCEL_TOOL), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_dbus_binding_value_get_scel_tool (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_DBUS_BINDING_TYPE_SCEL_TOOL), NULL);
	return value->data[0].v_pointer;
}


void icp_dbus_binding_value_set_scel_tool (GValue* value, gpointer v_object) {
	icpDBusBindingScelTool* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_DBUS_BINDING_TYPE_SCEL_TOOL));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_DBUS_BINDING_TYPE_SCEL_TOOL));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_dbus_binding_scel_tool_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_dbus_binding_scel_tool_unref (old);
	}
}


void icp_dbus_binding_value_take_scel_tool (GValue* value, gpointer v_object) {
	icpDBusBindingScelTool* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_DBUS_BINDING_TYPE_SCEL_TOOL));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_DBUS_BINDING_TYPE_SCEL_TOOL));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_dbus_binding_scel_tool_unref (old);
	}
}


static void icp_dbus_binding_scel_tool_class_init (icpDBusBindingScelToolClass * klass) {
	icp_dbus_binding_scel_tool_parent_class = g_type_class_peek_parent (klass);
	ICP_DBUS_BINDING_SCEL_TOOL_CLASS (klass)->finalize = icp_dbus_binding_scel_tool_finalize;
}


static void icp_dbus_binding_scel_tool_instance_init (icpDBusBindingScelTool * self) {
	self->ref_count = 1;
}


static void icp_dbus_binding_scel_tool_finalize (icpDBusBindingScelTool* obj) {
	icpDBusBindingScelTool * self;
	self = ICP_DBUS_BINDING_SCEL_TOOL (obj);
}


GType icp_dbus_binding_scel_tool_get_type (void) {
	static volatile gsize icp_dbus_binding_scel_tool_type_id__volatile = 0;
	if (g_once_init_enter (&icp_dbus_binding_scel_tool_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_dbus_binding_value_scel_tool_init, icp_dbus_binding_value_scel_tool_free_value, icp_dbus_binding_value_scel_tool_copy_value, icp_dbus_binding_value_scel_tool_peek_pointer, "p", icp_dbus_binding_value_scel_tool_collect_value, "p", icp_dbus_binding_value_scel_tool_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpDBusBindingScelToolClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_dbus_binding_scel_tool_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpDBusBindingScelTool), 0, (GInstanceInitFunc) icp_dbus_binding_scel_tool_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_dbus_binding_scel_tool_type_id;
		icp_dbus_binding_scel_tool_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpDBusBindingScelTool", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_dbus_binding_scel_tool_type_id__volatile, icp_dbus_binding_scel_tool_type_id);
	}
	return icp_dbus_binding_scel_tool_type_id__volatile;
}


gpointer icp_dbus_binding_scel_tool_ref (gpointer instance) {
	icpDBusBindingScelTool* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_dbus_binding_scel_tool_unref (gpointer instance) {
	icpDBusBindingScelTool* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_DBUS_BINDING_SCEL_TOOL_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


gboolean icp_dbus_binding_cloud_pinyin_cloud_set_response (icpDBusBindingCloudPinyin* self, const char* pinyins, const char* content, gint priority) {
	gboolean result = FALSE;
	g_return_val_if_fail (ICP_DBUS_BINDING_IS_CLOUD_PINYIN (self), FALSE);
	g_return_val_if_fail (pinyins != NULL, FALSE);
	g_return_val_if_fail (content != NULL, FALSE);
	result = icp_dbus_binding_set_response (pinyins, content, priority);
	return result;
}


char* icp_dbus_binding_cloud_pinyin_cloud_try_query (icpDBusBindingCloudPinyin* self, const char* pinyins) {
	char* result = NULL;
	g_return_val_if_fail (ICP_DBUS_BINDING_IS_CLOUD_PINYIN (self), NULL);
	g_return_val_if_fail (pinyins != NULL, NULL);
	result = icp_dbus_binding_query (pinyins);
	return result;
}


char* icp_dbus_binding_cloud_pinyin_convert (icpDBusBindingCloudPinyin* self, const char* pinyins) {
	char* result = NULL;
	icpPinyinSequence* _tmp0_;
	char* _tmp1_;
	g_return_val_if_fail (ICP_DBUS_BINDING_IS_CLOUD_PINYIN (self), NULL);
	g_return_val_if_fail (pinyins != NULL, NULL);
	result = (_tmp1_ = icp_dbus_binding_convert (_tmp0_ = icp_pinyin_sequence_new (pinyins), FALSE, &icp_dbus_binding_last_cloud_length), _icp_pinyin_sequence_unref0 (_tmp0_), _tmp1_);
	return result;
}


void icp_dbus_binding_cloud_pinyin_local_remember_phrase (icpDBusBindingCloudPinyin* self, const char* phrase) {
	icpPinyinSequence* sequence;
	icpPinyinSequence* _tmp0_ = NULL;
	icpPinyinSequence* _tmp1_;
	g_return_if_fail (ICP_DBUS_BINDING_IS_CLOUD_PINYIN (self));
	g_return_if_fail (phrase != NULL);
	sequence = NULL;
	icp_database_reverse_convert (phrase, &_tmp0_);
	sequence = (_tmp1_ = _tmp0_, _icp_pinyin_sequence_unref0 (sequence), _tmp1_);
	icp_database_insert (phrase, sequence, -3000.0, 200, TRUE);
	_icp_pinyin_sequence_unref0 (sequence);
}


char* icp_dbus_binding_cloud_pinyin_local_reverse_convert (icpDBusBindingCloudPinyin* self, const char* content) {
	char* result = NULL;
	icpPinyinSequence* ps;
	icpPinyinSequence* _tmp0_ = NULL;
	icpPinyinSequence* _tmp1_;
	g_return_val_if_fail (ICP_DBUS_BINDING_IS_CLOUD_PINYIN (self), NULL);
	g_return_val_if_fail (content != NULL, NULL);
	ps = NULL;
	icp_database_reverse_convert (content, &_tmp0_);
	ps = (_tmp1_ = _tmp0_, _icp_pinyin_sequence_unref0 (ps), _tmp1_);
	result = icp_pinyin_sequence_to_string (ps, 0, -1);
	_icp_pinyin_sequence_unref0 (ps);
	return result;
}


void icp_dbus_binding_cloud_pinyin_import_scel (icpDBusBindingCloudPinyin* self, const char* filename) {
	g_return_if_fail (ICP_DBUS_BINDING_IS_CLOUD_PINYIN (self));
	g_return_if_fail (filename != NULL);
	icp_dbus_binding_scel_tool_import (filename);
}


icpDBusBindingCloudPinyin* icp_dbus_binding_cloud_pinyin_construct (GType object_type) {
	icpDBusBindingCloudPinyin * self = NULL;
	self = (icpDBusBindingCloudPinyin*) g_object_new (object_type, NULL);
	return self;
}


icpDBusBindingCloudPinyin* icp_dbus_binding_cloud_pinyin_new (void) {
	return icp_dbus_binding_cloud_pinyin_construct (ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN);
}


void _icp_dbus_binding_cloud_pinyin_dbus_unregister (DBusConnection* connection, void* _user_data_) {
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_introspect (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter;
	GString* xml_data;
	char** children;
	int i;
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	xml_data = g_string_new ("<!DOCTYPE node PUBLIC \"-//freedesktop//DTD D-BUS Object Introspection 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd\">\n");
	g_string_append (xml_data, "<node>\n<interface name=\"org.freedesktop.DBus.Introspectable\">\n  <method name=\"Introspect\">\n    <arg name=\"data\" direction=\"out\" type=\"s\"/>\n  </method>\n</interface>\n<interface name=\"org.freedesktop.DBus.Properties\">\n  <method name=\"Get\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"out\" type=\"v\"/>\n  </method>\n  <method name=\"Set\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"propname\" direction=\"in\" type=\"s\"/>\n    <arg name=\"value\" direction=\"in\" type=\"v\"/>\n  </method>\n  <method name=\"GetAll\">\n    <arg name=\"interface\" direction=\"in\" type=\"s\"/>\n    <arg name=\"props\" direction=\"out\" type=\"a{sv}\"/>\n  </method>\n</interface>\n<interface name=\"org.ibus.CloudPinyin\">\n  <method name=\"CloudSetResponse\">\n    <arg name=\"pinyins\" type=\"s\" direction=\"in\"/>\n    <arg name=\"content\" type=\"s\" direction=\"in\"/>\n    <arg name=\"priority\" type=\"i\" direction=\"in\"/>\n    <arg name=\"result\" type=\"b\" direction=\"out\"/>\n  </method>\n  <method name=\"CloudTryQuery\">\n    <arg name=\"pinyins\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"s\" direction=\"out\"/>\n  </method>\n  <method name=\"Convert\">\n    <arg name=\"pinyins\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"s\" direction=\"out\"/>\n  </method>\n  <method name=\"LocalRememberPhrase\">\n    <arg name=\"phrase\" type=\"s\" direction=\"in\"/>\n  </method>\n  <method name=\"LocalReverseConvert\">\n    <arg name=\"content\" type=\"s\" direction=\"in\"/>\n    <arg name=\"result\" type=\"s\" direction=\"out\"/>\n  </method>\n  <method name=\"ImportScel\">\n    <arg name=\"filename\" type=\"s\" direction=\"in\"/>\n  </method>\n</interface>\n");
	dbus_connection_list_registered (connection, g_object_get_data ((GObject *) self, "dbus_object_path"), &children);
	for (i = 0; children[i]; i++) {
		g_string_append_printf (xml_data, "<node name=\"%s\"/>\n", children[i]);
	}
	dbus_free_string_array (children);
	g_string_append (xml_data, "</node>\n");
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &xml_data->str);
	g_string_free (xml_data, TRUE);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_property_get_all (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessage* reply;
	DBusMessageIter iter, reply_iter, subiter;
	char* interface_name;
	const char* _tmp0_;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &reply_iter);
	dbus_message_iter_get_basic (&iter, &_tmp0_);
	dbus_message_iter_next (&iter);
	interface_name = g_strdup (_tmp0_);
	if (strcmp (interface_name, "org.ibus.CloudPinyin") == 0) {
		dbus_message_iter_open_container (&reply_iter, DBUS_TYPE_ARRAY, "{sv}", &subiter);
		dbus_message_iter_close_container (&reply_iter, &subiter);
	} else {
		dbus_message_unref (reply);
		reply = NULL;
	}
	g_free (interface_name);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_cloud_set_response (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* pinyins = NULL;
	const char* _tmp1_;
	char* content = NULL;
	const char* _tmp2_;
	gint priority = 0;
	dbus_int32_t _tmp3_;
	gboolean result;
	DBusMessage* reply;
	dbus_bool_t _tmp4_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "ssi")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp1_);
	dbus_message_iter_next (&iter);
	pinyins = g_strdup (_tmp1_);
	dbus_message_iter_get_basic (&iter, &_tmp2_);
	dbus_message_iter_next (&iter);
	content = g_strdup (_tmp2_);
	dbus_message_iter_get_basic (&iter, &_tmp3_);
	dbus_message_iter_next (&iter);
	priority = _tmp3_;
	result = icp_dbus_binding_cloud_pinyin_cloud_set_response (self, pinyins, content, priority);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (pinyins);
	_g_free0 (content);
	_tmp4_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_BOOLEAN, &_tmp4_);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_cloud_try_query (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* pinyins = NULL;
	const char* _tmp5_;
	char* result;
	DBusMessage* reply;
	const char* _tmp6_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp5_);
	dbus_message_iter_next (&iter);
	pinyins = g_strdup (_tmp5_);
	result = icp_dbus_binding_cloud_pinyin_cloud_try_query (self, pinyins);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (pinyins);
	_tmp6_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp6_);
	_g_free0 (result);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_convert (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* pinyins = NULL;
	const char* _tmp7_;
	char* result;
	DBusMessage* reply;
	const char* _tmp8_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp7_);
	dbus_message_iter_next (&iter);
	pinyins = g_strdup (_tmp7_);
	result = icp_dbus_binding_cloud_pinyin_convert (self, pinyins);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (pinyins);
	_tmp8_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp8_);
	_g_free0 (result);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_local_remember_phrase (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* phrase = NULL;
	const char* _tmp9_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp9_);
	dbus_message_iter_next (&iter);
	phrase = g_strdup (_tmp9_);
	icp_dbus_binding_cloud_pinyin_local_remember_phrase (self, phrase);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (phrase);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_local_reverse_convert (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* content = NULL;
	const char* _tmp10_;
	char* result;
	DBusMessage* reply;
	const char* _tmp11_;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp10_);
	dbus_message_iter_next (&iter);
	content = g_strdup (_tmp10_);
	result = icp_dbus_binding_cloud_pinyin_local_reverse_convert (self, content);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (content);
	_tmp11_ = result;
	dbus_message_iter_append_basic (&iter, DBUS_TYPE_STRING, &_tmp11_);
	_g_free0 (result);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


static DBusHandlerResult _dbus_icp_dbus_binding_cloud_pinyin_import_scel (icpDBusBindingCloudPinyin* self, DBusConnection* connection, DBusMessage* message) {
	DBusMessageIter iter;
	GError* error;
	char* filename = NULL;
	const char* _tmp12_;
	DBusMessage* reply;
	error = NULL;
	if (strcmp (dbus_message_get_signature (message), "s")) {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
	dbus_message_iter_init (message, &iter);
	dbus_message_iter_get_basic (&iter, &_tmp12_);
	dbus_message_iter_next (&iter);
	filename = g_strdup (_tmp12_);
	icp_dbus_binding_cloud_pinyin_import_scel (self, filename);
	reply = dbus_message_new_method_return (message);
	dbus_message_iter_init_append (reply, &iter);
	_g_free0 (filename);
	if (reply) {
		dbus_connection_send (connection, reply, NULL);
		dbus_message_unref (reply);
		return DBUS_HANDLER_RESULT_HANDLED;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


DBusHandlerResult icp_dbus_binding_cloud_pinyin_dbus_message (DBusConnection* connection, DBusMessage* message, void* object) {
	DBusHandlerResult result;
	result = DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Introspectable", "Introspect")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_introspect (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.freedesktop.DBus.Properties", "GetAll")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_property_get_all (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.ibus.CloudPinyin", "CloudSetResponse")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_cloud_set_response (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.ibus.CloudPinyin", "CloudTryQuery")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_cloud_try_query (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.ibus.CloudPinyin", "Convert")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_convert (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.ibus.CloudPinyin", "LocalRememberPhrase")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_local_remember_phrase (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.ibus.CloudPinyin", "LocalReverseConvert")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_local_reverse_convert (object, connection, message);
	} else if (dbus_message_is_method_call (message, "org.ibus.CloudPinyin", "ImportScel")) {
		result = _dbus_icp_dbus_binding_cloud_pinyin_import_scel (object, connection, message);
	}
	if (result == DBUS_HANDLER_RESULT_HANDLED) {
		return result;
	} else {
		return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
	}
}


void icp_dbus_binding_cloud_pinyin_dbus_register_object (DBusConnection* connection, const char* path, void* object) {
	if (!g_object_get_data (object, "dbus_object_path")) {
		g_object_set_data (object, "dbus_object_path", g_strdup (path));
		dbus_connection_register_object_path (connection, path, &_icp_dbus_binding_cloud_pinyin_dbus_path_vtable, object);
		g_object_weak_ref (object, _vala_dbus_unregister_object, connection);
	}
}


static void icp_dbus_binding_cloud_pinyin_class_init (icpDBusBindingCloudPinyinClass * klass) {
	icp_dbus_binding_cloud_pinyin_parent_class = g_type_class_peek_parent (klass);
	g_type_set_qdata (ICP_DBUS_BINDING_TYPE_CLOUD_PINYIN, g_quark_from_static_string ("DBusObjectVTable"), (void*) (&_icp_dbus_binding_cloud_pinyin_dbus_vtable));
}


static void icp_dbus_binding_cloud_pinyin_instance_init (icpDBusBindingCloudPinyin * self) {
}


GType icp_dbus_binding_cloud_pinyin_get_type (void) {
	static volatile gsize icp_dbus_binding_cloud_pinyin_type_id__volatile = 0;
	if (g_once_init_enter (&icp_dbus_binding_cloud_pinyin_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (icpDBusBindingCloudPinyinClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_dbus_binding_cloud_pinyin_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpDBusBindingCloudPinyin), 0, (GInstanceInitFunc) icp_dbus_binding_cloud_pinyin_instance_init, NULL };
		GType icp_dbus_binding_cloud_pinyin_type_id;
		icp_dbus_binding_cloud_pinyin_type_id = g_type_register_static (G_TYPE_OBJECT, "icpDBusBindingCloudPinyin", &g_define_type_info, 0);
		g_once_init_leave (&icp_dbus_binding_cloud_pinyin_type_id__volatile, icp_dbus_binding_cloud_pinyin_type_id);
	}
	return icp_dbus_binding_cloud_pinyin_type_id__volatile;
}


static void icp_value_dbus_binding_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_value_dbus_binding_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_dbus_binding_unref (value->data[0].v_pointer);
	}
}


static void icp_value_dbus_binding_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_dbus_binding_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_value_dbus_binding_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_value_dbus_binding_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpDBusBinding* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_dbus_binding_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_value_dbus_binding_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpDBusBinding** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_dbus_binding_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_param_spec_dbus_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpParamSpecDBusBinding* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_TYPE_DBUS_BINDING), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_value_get_dbus_binding (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_DBUS_BINDING), NULL);
	return value->data[0].v_pointer;
}


void icp_value_set_dbus_binding (GValue* value, gpointer v_object) {
	icpDBusBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_DBUS_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_DBUS_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_dbus_binding_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_dbus_binding_unref (old);
	}
}


void icp_value_take_dbus_binding (GValue* value, gpointer v_object) {
	icpDBusBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_DBUS_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_DBUS_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_dbus_binding_unref (old);
	}
}


static void icp_dbus_binding_class_init (icpDBusBindingClass * klass) {
	icp_dbus_binding_parent_class = g_type_class_peek_parent (klass);
	ICP_DBUS_BINDING_CLASS (klass)->finalize = icp_dbus_binding_finalize;
}


static void icp_dbus_binding_instance_init (icpDBusBinding * self) {
	self->ref_count = 1;
}


static void icp_dbus_binding_finalize (icpDBusBinding* obj) {
	icpDBusBinding * self;
	self = ICP_DBUS_BINDING (obj);
}


GType icp_dbus_binding_get_type (void) {
	static volatile gsize icp_dbus_binding_type_id__volatile = 0;
	if (g_once_init_enter (&icp_dbus_binding_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_value_dbus_binding_init, icp_value_dbus_binding_free_value, icp_value_dbus_binding_copy_value, icp_value_dbus_binding_peek_pointer, "p", icp_value_dbus_binding_collect_value, "p", icp_value_dbus_binding_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpDBusBindingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_dbus_binding_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpDBusBinding), 0, (GInstanceInitFunc) icp_dbus_binding_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_dbus_binding_type_id;
		icp_dbus_binding_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpDBusBinding", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_dbus_binding_type_id__volatile, icp_dbus_binding_type_id);
	}
	return icp_dbus_binding_type_id__volatile;
}


gpointer icp_dbus_binding_ref (gpointer instance) {
	icpDBusBinding* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_dbus_binding_unref (gpointer instance) {
	icpDBusBinding* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_DBUS_BINDING_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




