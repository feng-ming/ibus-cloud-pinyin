/* lua-binding.c generated by valac 0.10.4, the Vala compiler
 * generated from lua-binding.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <lua.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <ibus.h>
#include <signal.h>
#include <sys/types.h>
#include <gobject/gvaluecollector.h>


#define ICP_TYPE_LUA_BINDING (icp_lua_binding_get_type ())
#define ICP_LUA_BINDING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_TYPE_LUA_BINDING, icpLuaBinding))
#define ICP_LUA_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_TYPE_LUA_BINDING, icpLuaBindingClass))
#define ICP_IS_LUA_BINDING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_TYPE_LUA_BINDING))
#define ICP_IS_LUA_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_TYPE_LUA_BINDING))
#define ICP_LUA_BINDING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_TYPE_LUA_BINDING, icpLuaBindingClass))

typedef struct _icpLuaBinding icpLuaBinding;
typedef struct _icpLuaBindingClass icpLuaBindingClass;
typedef struct _icpLuaBindingPrivate icpLuaBindingPrivate;

#define ICP_LUA_BINDING_TYPE_CLOUD_ENGINE (icp_lua_binding_cloud_engine_get_type ())
#define ICP_LUA_BINDING_CLOUD_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_LUA_BINDING_TYPE_CLOUD_ENGINE, icpLuaBindingCloudEngine))
#define ICP_LUA_BINDING_CLOUD_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_LUA_BINDING_TYPE_CLOUD_ENGINE, icpLuaBindingCloudEngineClass))
#define ICP_LUA_BINDING_IS_CLOUD_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_LUA_BINDING_TYPE_CLOUD_ENGINE))
#define ICP_LUA_BINDING_IS_CLOUD_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_LUA_BINDING_TYPE_CLOUD_ENGINE))
#define ICP_LUA_BINDING_CLOUD_ENGINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_LUA_BINDING_TYPE_CLOUD_ENGINE, icpLuaBindingCloudEngineClass))

typedef struct _icpLuaBindingCloudEngine icpLuaBindingCloudEngine;
typedef struct _icpLuaBindingCloudEngineClass icpLuaBindingCloudEngineClass;

#define ICP_LUA_BINDING_TYPE_REQUEST_STATUS (icp_lua_binding_request_status_get_type ())
#define ICP_LUA_BINDING_REQUEST_STATUS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_LUA_BINDING_TYPE_REQUEST_STATUS, icpLuaBindingRequestStatus))
#define ICP_LUA_BINDING_REQUEST_STATUS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_LUA_BINDING_TYPE_REQUEST_STATUS, icpLuaBindingRequestStatusClass))
#define ICP_LUA_BINDING_IS_REQUEST_STATUS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_LUA_BINDING_TYPE_REQUEST_STATUS))
#define ICP_LUA_BINDING_IS_REQUEST_STATUS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_LUA_BINDING_TYPE_REQUEST_STATUS))
#define ICP_LUA_BINDING_REQUEST_STATUS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_LUA_BINDING_TYPE_REQUEST_STATUS, icpLuaBindingRequestStatusClass))

typedef struct _icpLuaBindingRequestStatus icpLuaBindingRequestStatus;
typedef struct _icpLuaBindingRequestStatusClass icpLuaBindingRequestStatusClass;

#define ICP_LUA_BINDING_TYPE_REQUEST_GROUP (icp_lua_binding_request_group_get_type ())
#define ICP_LUA_BINDING_REQUEST_GROUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_LUA_BINDING_TYPE_REQUEST_GROUP, icpLuaBindingRequestGroup))
#define ICP_LUA_BINDING_REQUEST_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_LUA_BINDING_TYPE_REQUEST_GROUP, icpLuaBindingRequestGroupClass))
#define ICP_LUA_BINDING_IS_REQUEST_GROUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_LUA_BINDING_TYPE_REQUEST_GROUP))
#define ICP_LUA_BINDING_IS_REQUEST_GROUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_LUA_BINDING_TYPE_REQUEST_GROUP))
#define ICP_LUA_BINDING_REQUEST_GROUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_LUA_BINDING_TYPE_REQUEST_GROUP, icpLuaBindingRequestGroupClass))

typedef struct _icpLuaBindingRequestGroup icpLuaBindingRequestGroup;
typedef struct _icpLuaBindingRequestGroupClass icpLuaBindingRequestGroupClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _icpLuaBindingCloudEnginePrivate icpLuaBindingCloudEnginePrivate;
#define _icp_lua_binding_cloud_engine_unref0(var) ((var == NULL) ? NULL : (var = (icp_lua_binding_cloud_engine_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _icpLuaBindingRequestGroupPrivate icpLuaBindingRequestGroupPrivate;
#define _icp_lua_binding_request_group_unref0(var) ((var == NULL) ? NULL : (var = (icp_lua_binding_request_group_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define ICP_CONFIG_COLORS_TYPE_COLOR (icp_config_colors_color_get_type ())
#define ICP_CONFIG_COLORS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColor))
#define ICP_CONFIG_COLORS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColorClass))
#define ICP_CONFIG_COLORS_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_COLORS_TYPE_COLOR))
#define ICP_CONFIG_COLORS_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_COLORS_TYPE_COLOR))
#define ICP_CONFIG_COLORS_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColorClass))

typedef struct _icpConfigColorsColor icpConfigColorsColor;
typedef struct _icpConfigColorsColorClass icpConfigColorsColorClass;
#define _icp_config_colors_color_unref0(var) ((var == NULL) ? NULL : (var = (icp_config_colors_color_unref (var), NULL)))

#define ICP_CONFIG_TYPE_KEY (icp_config_key_get_type ())
#define ICP_CONFIG_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_TYPE_KEY, icpConfigKey))
#define ICP_CONFIG_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_TYPE_KEY, icpConfigKeyClass))
#define ICP_CONFIG_IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_TYPE_KEY))
#define ICP_CONFIG_IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_TYPE_KEY))
#define ICP_CONFIG_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_TYPE_KEY, icpConfigKeyClass))

typedef struct _icpConfigKey icpConfigKey;
typedef struct _icpConfigKeyClass icpConfigKeyClass;
#define _icp_config_key_unref0(var) ((var == NULL) ? NULL : (var = (icp_config_key_unref (var), NULL)))

#define ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE (icp_ibus_binding_cloud_pinyin_engine_get_type ())
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE, icpIBusBindingCloudPinyinEngine))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE, icpIBusBindingCloudPinyinEngineClass))
#define ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE))
#define ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE, icpIBusBindingCloudPinyinEngineClass))

typedef struct _icpIBusBindingCloudPinyinEngine icpIBusBindingCloudPinyinEngine;
typedef struct _icpIBusBindingCloudPinyinEngineClass icpIBusBindingCloudPinyinEngineClass;
#define _lua_close0(var) ((var == NULL) ? NULL : (var = (lua_close (var), NULL)))
#define _g_thread_pool_free0(var) ((var == NULL) ? NULL : (var = (g_thread_pool_free (var, FALSE, TRUE), NULL)))
typedef struct _icpLuaBindingParamSpecCloudEngine icpLuaBindingParamSpecCloudEngine;
typedef struct _icpLuaBindingRequestStatusPrivate icpLuaBindingRequestStatusPrivate;
#define _icp_lua_binding_request_status_unref0(var) ((var == NULL) ? NULL : (var = (icp_lua_binding_request_status_unref (var), NULL)))
typedef struct _icpLuaBindingParamSpecRequestStatus icpLuaBindingParamSpecRequestStatus;
typedef struct _icpLuaBindingParamSpecRequestGroup icpLuaBindingParamSpecRequestGroup;
typedef struct _icpParamSpecLuaBinding icpParamSpecLuaBinding;

struct _icpLuaBinding {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpLuaBindingPrivate * priv;
};

struct _icpLuaBindingClass {
	GTypeClass parent_class;
	void (*finalize) (icpLuaBinding *self);
};

struct _icpLuaBindingCloudEngine {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpLuaBindingCloudEnginePrivate * priv;
	double response_time_rank;
	gint response_count;
	double response_time;
};

struct _icpLuaBindingCloudEngineClass {
	GTypeClass parent_class;
	void (*finalize) (icpLuaBindingCloudEngine *self);
};

struct _icpLuaBindingRequestGroup {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpLuaBindingRequestGroupPrivate * priv;
	gboolean* done;
	gboolean can_clean;
	gint highest_priority;
	char* pinyins;
	double timeout;
	GeeArrayList* status_list;
};

struct _icpLuaBindingRequestGroupClass {
	GTypeClass parent_class;
	void (*finalize) (icpLuaBindingRequestGroup *self);
};

struct _icpLuaBindingCloudEnginePrivate {
	GStaticRecMutex __lock_response_time_rank;
	gint _priority;
	char* _script;
};

struct _icpLuaBindingParamSpecCloudEngine {
	GParamSpec parent_instance;
};

struct _icpLuaBindingRequestStatus {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpLuaBindingRequestStatusPrivate * priv;
	GPid pid;
	gboolean done;
};

struct _icpLuaBindingRequestStatusClass {
	GTypeClass parent_class;
	void (*finalize) (icpLuaBindingRequestStatus *self);
};

struct _icpLuaBindingRequestStatusPrivate {
	double start_time;
	icpLuaBindingCloudEngine* pengine;
	gint _id;
	icpLuaBindingRequestGroup* group;
	icpLuaBindingCloudEngine* engine;
};

struct _icpLuaBindingParamSpecRequestStatus {
	GParamSpec parent_instance;
};

struct _icpLuaBindingParamSpecRequestGroup {
	GParamSpec parent_instance;
};

struct _icpParamSpecLuaBinding {
	GParamSpec parent_instance;
};


static lua_State* icp_lua_binding_vm;
static lua_State* icp_lua_binding_vm = NULL;
static GThreadPool* icp_lua_binding_thread_pool;
static GThreadPool* icp_lua_binding_thread_pool = NULL;
static GeeLinkedList* icp_lua_binding_script_pool;
static GeeLinkedList* icp_lua_binding_script_pool = NULL;
static GeeHashMap* icp_lua_binding_engines;
static GeeHashMap* icp_lua_binding_engines = NULL;
static gboolean icp_lua_binding_in_configuration;
static gboolean icp_lua_binding_in_configuration = FALSE;
static GeeHashMap* icp_lua_binding_pid_to_request_status;
static GeeHashMap* icp_lua_binding_pid_to_request_status = NULL;
static GeeArrayList* icp_lua_binding_request_group;
static GeeArrayList* icp_lua_binding_request_group = NULL;
extern GeeHashMap* icp_pinyin_cutting_adjusts;
extern icpConfigColorsColor* icp_config_colors_buffer_raw;
extern icpConfigColorsColor* icp_config_colors_buffer_pinyin;
extern icpConfigColorsColor* icp_config_colors_candidate_local;
extern icpConfigColorsColor* icp_config_colors_candidate_remote;
extern icpConfigColorsColor* icp_config_colors_preedit_correcting;
extern icpConfigColorsColor* icp_config_colors_preedit_local;
extern icpConfigColorsColor* icp_config_colors_preedit_remote;
extern icpConfigColorsColor* icp_config_colors_preedit_fixed;
extern gboolean icp_config_switches_double_pinyin;
extern gboolean icp_config_switches_background_request;
extern gboolean icp_config_switches_always_show_candidates;
extern gboolean icp_config_switches_show_pinyin_auxiliary;
extern gboolean icp_config_switches_show_raw_in_auxiliary;
extern gboolean icp_config_switches_default_offline_mode;
extern gboolean icp_config_switches_default_chinese_mode;
extern gboolean icp_config_switches_default_traditional_mode;
extern double icp_config_timeouts_request;
extern double icp_config_timeouts_prerequest;
extern double icp_config_timeouts_selection;
extern gint icp_config_limits_db_query_limit;
extern gint icp_config_limits_prerequest_retry_limit;
extern gint icp_config_limits_request_retry_limit;
extern gint icp_config_limits_cloud_candidates_limit;
extern icpIBusBindingCloudPinyinEngine* icp_ibus_binding_active_engine;
extern char* icp_config_commandline_options_startup_script;
static gpointer icp_lua_binding_cloud_engine_parent_class = NULL;
static gpointer icp_lua_binding_request_status_parent_class = NULL;
static gpointer icp_lua_binding_request_group_parent_class = NULL;
static gpointer icp_lua_binding_parent_class = NULL;

gpointer icp_lua_binding_ref (gpointer instance);
void icp_lua_binding_unref (gpointer instance);
GParamSpec* icp_param_spec_lua_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_value_set_lua_binding (GValue* value, gpointer v_object);
void icp_value_take_lua_binding (GValue* value, gpointer v_object);
gpointer icp_value_get_lua_binding (const GValue* value);
GType icp_lua_binding_get_type (void) G_GNUC_CONST;
enum  {
	ICP_LUA_BINDING_DUMMY_PROPERTY
};
static gpointer icp_lua_binding_cloud_engine_ref (gpointer instance);
static void icp_lua_binding_cloud_engine_unref (gpointer instance);
static GParamSpec* icp_lua_binding_param_spec_cloud_engine (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void icp_lua_binding_value_set_cloud_engine (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void icp_lua_binding_value_take_cloud_engine (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer icp_lua_binding_value_get_cloud_engine (const GValue* value) G_GNUC_UNUSED;
static GType icp_lua_binding_cloud_engine_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gpointer icp_lua_binding_request_status_ref (gpointer instance);
static void icp_lua_binding_request_status_unref (gpointer instance);
static GParamSpec* icp_lua_binding_param_spec_request_status (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void icp_lua_binding_value_set_request_status (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void icp_lua_binding_value_take_request_status (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer icp_lua_binding_value_get_request_status (const GValue* value) G_GNUC_UNUSED;
static GType icp_lua_binding_request_status_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gpointer icp_lua_binding_request_group_ref (gpointer instance);
static void icp_lua_binding_request_group_unref (gpointer instance);
static GParamSpec* icp_lua_binding_param_spec_request_group (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void icp_lua_binding_value_set_request_group (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void icp_lua_binding_value_take_request_group (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer icp_lua_binding_value_get_request_group (const GValue* value) G_GNUC_UNUSED;
static GType icp_lua_binding_request_group_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
gint icp_lua_binding_get_engine_count (void);
gint icp_lua_binding_get_engine_speed_rank (gint low, gint high);
void icp_lua_binding_show_engine_speed_rank (void);
void icp_frontend_notify (const char* title, const char* content, const char* icon);
const char* icp_config_get_program_main_icon (void);
void icp_lua_binding_start_requests (const char* pinyins, double timeout, gboolean* done);
static icpLuaBindingRequestGroup* icp_lua_binding_request_group_new (const char* pinyins, double timeout, gboolean* done);
static icpLuaBindingRequestGroup* icp_lua_binding_request_group_construct (GType object_type, const char* pinyins, double timeout, gboolean* done);
static icpLuaBinding* icp_lua_binding_new (void);
static icpLuaBinding* icp_lua_binding_construct (GType object_type);
static gboolean icp_lua_binding_check_permissions (gboolean should_in_configuration);
static gint icp_lua_binding_l_get_selection (lua_State* vm);
char* icp_frontend_get_selection (void);
static gint icp_lua_binding_l_set_cutting_adjust (lua_State* vm);
static gint icp_lua_binding_l_notify (lua_State* vm);
static gint icp_lua_binding_l_set_response (lua_State* vm);
gboolean icp_dbus_binding_set_response (const char* pinyins, const char* content, gint priority);
static gint icp_lua_binding_l_set_color (lua_State* vm);
static gint* _int_dup (gint* self);
gpointer icp_config_colors_color_ref (gpointer instance);
void icp_config_colors_color_unref (gpointer instance);
GParamSpec* icp_config_colors_param_spec_color (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_colors_value_set_color (GValue* value, gpointer v_object);
void icp_config_colors_value_take_color (GValue* value, gpointer v_object);
gpointer icp_config_colors_value_get_color (const GValue* value);
GType icp_config_colors_color_get_type (void) G_GNUC_CONST;
icpConfigColorsColor* icp_config_colors_color_new (gint* foreground, gint* background, gboolean underlined);
icpConfigColorsColor* icp_config_colors_color_construct (GType object_type, gint* foreground, gint* background, gboolean underlined);
static gint icp_lua_binding_l_set_switch (lua_State* vm);
static gint icp_lua_binding_l_set_timeout (lua_State* vm);
static gint icp_lua_binding_l_set_limit (lua_State* vm);
static gint icp_lua_binding_l_set_double_pinyin (lua_State* vm);
void icp_pinyin_double_pinyin_clear (void);
void icp_pinyin_double_pinyin_insert (const char* double_pinyin, const char* pinyin);
static gint icp_lua_binding_l_set_key (lua_State* vm);
icpConfigKey* icp_config_key_new (guint key, guint state, const char* label);
icpConfigKey* icp_config_key_construct (GType object_type, guint key, guint state, const char* label);
gpointer icp_config_key_ref (gpointer instance);
void icp_config_key_unref (gpointer instance);
GParamSpec* icp_config_param_spec_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_value_set_key (GValue* value, gpointer v_object);
void icp_config_value_take_key (GValue* value, gpointer v_object);
gpointer icp_config_value_get_key (const GValue* value);
GType icp_config_key_get_type (void) G_GNUC_CONST;
void icp_config_key_actions_set (icpConfigKey* key, const char* action);
static gint icp_lua_binding_l_set_candidate_labels (lua_State* vm);
void icp_config_candidate_labels_clear (void);
void icp_config_candidate_labels_add (const char* label, const char* label_alternative);
static gint icp_lua_binding_l_set_punctuation (lua_State* vm);
void icp_config_punctuations_set (gint half_char, const char* full_chars, gboolean only_after_chinese);
static gint icp_lua_binding_l_register_engine (lua_State* vm);
static icpLuaBindingCloudEngine* icp_lua_binding_cloud_engine_new (const char* script, gint priority);
static icpLuaBindingCloudEngine* icp_lua_binding_cloud_engine_construct (GType object_type, const char* script, gint priority);
static gint icp_lua_binding_l_commit (lua_State* vm);
GType icp_ibus_binding_cloud_pinyin_engine_get_type (void) G_GNUC_CONST;
void icp_ibus_binding_cloud_pinyin_engine_commit (icpIBusBindingCloudPinyinEngine* self, const char* content);
void icp_lua_binding_init (void);
const char* icp_config_get_user_config_path (void);
const char* icp_config_get_user_data_path (void);
const char* icp_config_get_user_cache_path (void);
const char* icp_config_get_global_data_path (void);
static gint _icp_lua_binding_l_notify_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_get_selection_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_commit_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_response_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_double_pinyin_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_key_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_candidate_labels_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_punctuation_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_switch_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_timeout_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_limit_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_color_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_set_cutting_adjust_lua_cfunction (lua_State* vm);
static gint _icp_lua_binding_l_register_engine_lua_cfunction (lua_State* vm);
static void icp_lua_binding_do_string_internal (void* data);
static void _icp_lua_binding_do_string_internal_gfunc (void* data, gpointer self);
void icp_lua_binding_load_configuration (void);
void icp_lua_binding_do_string (const char* script);
#define ICP_LUA_BINDING_CLOUD_ENGINE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_LUA_BINDING_TYPE_CLOUD_ENGINE, icpLuaBindingCloudEnginePrivate))
enum  {
	ICP_LUA_BINDING_CLOUD_ENGINE_DUMMY_PROPERTY
};
static void icp_lua_binding_cloud_engine_set_priority (icpLuaBindingCloudEngine* self, gint value);
static void icp_lua_binding_cloud_engine_set_script (icpLuaBindingCloudEngine* self, const char* value);
static void icp_lua_binding_cloud_engine_update_response_time_rank (icpLuaBindingCloudEngine* self, double time, gboolean successful, double timeout);
static gint icp_lua_binding_cloud_engine_get_priority (icpLuaBindingCloudEngine* self);
static const char* icp_lua_binding_cloud_engine_get_script (icpLuaBindingCloudEngine* self);
static void icp_lua_binding_cloud_engine_finalize (icpLuaBindingCloudEngine* obj);
#define ICP_LUA_BINDING_REQUEST_STATUS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_LUA_BINDING_TYPE_REQUEST_STATUS, icpLuaBindingRequestStatusPrivate))
enum  {
	ICP_LUA_BINDING_REQUEST_STATUS_DUMMY_PROPERTY
};
static icpLuaBindingRequestStatus* icp_lua_binding_request_status_new (icpLuaBindingRequestGroup* group, icpLuaBindingCloudEngine* engine, gint status_id);
static icpLuaBindingRequestStatus* icp_lua_binding_request_status_construct (GType object_type, icpLuaBindingRequestGroup* group, icpLuaBindingCloudEngine* engine, gint status_id);
static void icp_lua_binding_request_status_set_id (icpLuaBindingRequestStatus* self, gint value);
const char* icp_config_get_program_request (void);
double icp_database_get_atime (void);
static void _lambda3_ (GPid p, gint status, icpLuaBindingRequestStatus* self);
static void icp_lua_binding_request_group_notify_done (icpLuaBindingRequestGroup* self, gint id, gboolean stop_others);
static gint icp_lua_binding_request_status_get_id (icpLuaBindingRequestStatus* self);
static void __lambda3__gchild_watch_func (GPid pid, gint status, gpointer self);
static void icp_lua_binding_request_status_finalize (icpLuaBindingRequestStatus* obj);
enum  {
	ICP_LUA_BINDING_REQUEST_GROUP_DUMMY_PROPERTY
};
static void icp_lua_binding_request_group_finalize (icpLuaBindingRequestGroup* obj);
static void icp_lua_binding_finalize (icpLuaBinding* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);



gint icp_lua_binding_get_engine_count (void) {
	gint result = 0;
	result = gee_map_get_size (GEE_MAP (icp_lua_binding_engines));
	return result;
}


gint icp_lua_binding_get_engine_speed_rank (gint low, gint high) {
	gint result = 0;
	double rank_best;
	gint r;
	rank_best = (double) 1;
	{
		GeeCollection* _tmp0_;
		GeeIterator* _tmp1_;
		GeeIterator* _engine_it;
		_engine_it = (_tmp1_ = gee_iterable_iterator (GEE_ITERABLE (_tmp0_ = gee_map_get_values (GEE_MAP (icp_lua_binding_engines)))), _g_object_unref0 (_tmp0_), _tmp1_);
		while (TRUE) {
			icpLuaBindingCloudEngine* engine;
			double rank;
			if (!gee_iterator_next (_engine_it)) {
				break;
			}
			engine = (icpLuaBindingCloudEngine*) gee_iterator_get (_engine_it);
			rank = engine->response_time_rank;
			if (rank < rank_best) {
				rank_best = rank;
			}
			_icp_lua_binding_cloud_engine_unref0 (engine);
		}
		_g_object_unref0 (_engine_it);
	}
	r = low + ((gint) floor (((high - low) + 1) * (1 - rank_best)));
	if (r > high) {
		r = high;
	}
	if (r < low) {
		r = low;
	}
	result = r;
	return result;
}


void icp_lua_binding_show_engine_speed_rank (void) {
	char* content;
	char* _tmp5_;
	if (gee_map_get_size (GEE_MAP (icp_lua_binding_engines)) == 0) {
		return;
	}
	content = g_strdup ("平均响应时间(仅成功请求):");
	{
		GeeIterator* _i_it;
		_i_it = gee_iterable_iterator (GEE_ITERABLE (icp_lua_binding_engines));
		while (TRUE) {
			GeeMapEntry* i;
			char* _tmp0_;
			char* _tmp1_;
			if (!gee_iterator_next (_i_it)) {
				break;
			}
			i = (GeeMapEntry*) gee_iterator_get (_i_it);
			content = (_tmp1_ = g_strconcat (content, _tmp0_ = g_strdup_printf ("\n    %s: ", (const char*) gee_map_entry_get_key (i)), NULL), _g_free0 (content), _tmp1_);
			_g_free0 (_tmp0_);
			if (((icpLuaBindingCloudEngine*) gee_map_entry_get_value (i))->response_count == 0) {
				char* _tmp2_;
				content = (_tmp2_ = g_strconcat (content, "N/A", NULL), _g_free0 (content), _tmp2_);
			} else {
				char* _tmp3_;
				char* _tmp4_;
				content = (_tmp4_ = g_strconcat (content, _tmp3_ = g_strdup_printf ("%.3f s", ((icpLuaBindingCloudEngine*) gee_map_entry_get_value (i))->response_time / ((icpLuaBindingCloudEngine*) gee_map_entry_get_value (i))->response_count), NULL), _g_free0 (content), _tmp4_);
				_g_free0 (_tmp3_);
			}
			_g_object_unref0 (i);
		}
		_g_object_unref0 (_i_it);
	}
	content = (_tmp5_ = g_strconcat (content, "\n采用次数:", NULL), _g_free0 (content), _tmp5_);
	{
		GeeIterator* _i_it;
		_i_it = gee_iterable_iterator (GEE_ITERABLE (icp_lua_binding_engines));
		while (TRUE) {
			GeeMapEntry* i;
			char* _tmp6_;
			char* _tmp7_;
			if (!gee_iterator_next (_i_it)) {
				break;
			}
			i = (GeeMapEntry*) gee_iterator_get (_i_it);
			content = (_tmp7_ = g_strconcat (content, _tmp6_ = g_strdup_printf ("\n    %s: %d", (const char*) gee_map_entry_get_key (i), ((icpLuaBindingCloudEngine*) gee_map_entry_get_value (i))->response_count), NULL), _g_free0 (content), _tmp7_);
			_g_free0 (_tmp6_);
			_g_object_unref0 (i);
		}
		_g_object_unref0 (_i_it);
	}
	icp_frontend_notify ("网络请求数据", content, icp_config_get_program_main_icon ());
	_g_free0 (content);
}


void icp_lua_binding_start_requests (const char* pinyins, double timeout, gboolean* done) {
	gboolean can_clean;
	icpLuaBindingRequestGroup* _tmp0_;
	g_return_if_fail (pinyins != NULL);
	can_clean = TRUE;
	{
		GeeIterator* _r_it;
		_r_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (icp_lua_binding_request_group));
		while (TRUE) {
			icpLuaBindingRequestGroup* r;
			if (!gee_iterator_next (_r_it)) {
				break;
			}
			r = (icpLuaBindingRequestGroup*) gee_iterator_get (_r_it);
			if (r->can_clean == FALSE) {
				can_clean = FALSE;
				_icp_lua_binding_request_group_unref0 (r);
				break;
			}
			_icp_lua_binding_request_group_unref0 (r);
		}
		_g_object_unref0 (_r_it);
	}
	if (can_clean) {
		gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (icp_lua_binding_request_group));
	}
	gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (icp_lua_binding_request_group), _tmp0_ = icp_lua_binding_request_group_new (pinyins, timeout, done));
	_icp_lua_binding_request_group_unref0 (_tmp0_);
}


static icpLuaBinding* icp_lua_binding_construct (GType object_type) {
	icpLuaBinding* self = (icpLuaBinding*) g_type_create_instance (object_type);
	return self;
}


static icpLuaBinding* icp_lua_binding_new (void) {
	return icp_lua_binding_construct (ICP_TYPE_LUA_BINDING);
}


static gboolean icp_lua_binding_check_permissions (gboolean should_in_configuration) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	if (should_in_configuration) {
		_tmp0_ = !icp_lua_binding_in_configuration;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		icp_frontend_notify ("No permission", "Configurations must be done in startup script.", "stop");
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}


static gint icp_lua_binding_l_get_selection (lua_State* vm) {
	gint result = 0;
	char* _tmp0_;
	g_return_val_if_fail (vm != NULL, 0);
	lua_checkstack (vm, 1);
	lua_pushstring (vm, _tmp0_ = icp_frontend_get_selection ());
	_g_free0 (_tmp0_);
	result = 1;
	return result;
}


static char* string_replace (const char* self, const char* old, const char* replacement) {
	char* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		char* _tmp0_;
		GRegex* _tmp1_;
		GRegex* regex;
		char* _tmp2_;
		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch10_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch10_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp2_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally10;
	__catch10_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_assert_not_reached ();
			_g_error_free0 (e);
		}
	}
	__finally10:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gint icp_lua_binding_l_set_cutting_adjust (lua_State* vm) {
	gint result = 0;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	if (lua_isstring (vm, 1)) {
		char* cutting_adjust;
		char* _tmp0_;
		cutting_adjust = g_strdup (lua_tostring (vm, 1));
		gee_abstract_map_set (GEE_ABSTRACT_MAP (icp_pinyin_cutting_adjusts), _tmp0_ = string_replace (cutting_adjust, " ", ""), cutting_adjust);
		_g_free0 (_tmp0_);
		_g_free0 (cutting_adjust);
	}
	result = 0;
	return result;
}


static gint icp_lua_binding_l_notify (lua_State* vm) {
	gint result = 0;
	g_return_val_if_fail (vm != NULL, 0);
	if (lua_isstring (vm, 1)) {
		char* title;
		char* content;
		char* icon;
		title = g_strdup (lua_tostring (vm, 1));
		content = g_strdup ("");
		icon = g_strdup ("");
		if (lua_isstring (vm, 2)) {
			char* _tmp0_;
			content = (_tmp0_ = g_strdup (lua_tostring (vm, 2)), _g_free0 (content), _tmp0_);
		}
		if (lua_isstring (vm, 3)) {
			char* _tmp1_;
			icon = (_tmp1_ = g_strdup (lua_tostring (vm, 3)), _g_free0 (icon), _tmp1_);
		}
		icp_frontend_notify (title, content, icon);
		_g_free0 (icon);
		_g_free0 (content);
		_g_free0 (title);
	}
	result = 0;
	return result;
}


static gint icp_lua_binding_l_set_response (lua_State* vm) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	if (lua_isstring (vm, 1)) {
		_tmp0_ = lua_isstring (vm, 2);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		char* pinyins;
		char* content;
		gint priority;
		pinyins = g_strdup (lua_tostring (vm, 1));
		content = g_strdup (lua_tostring (vm, 2));
		priority = 128;
		if (lua_isnumber (vm, 3)) {
			priority = lua_tointeger (vm, 3);
		}
		icp_dbus_binding_set_response (pinyins, content, priority);
		_g_free0 (content);
		_g_free0 (pinyins);
	}
	result = 0;
	return result;
}


static gint* _int_dup (gint* self) {
	gint* dup;
	dup = g_new0 (gint, 1);
	memcpy (dup, self, sizeof (gint));
	return dup;
}


static gpointer __int_dup0 (gpointer self) {
	return self ? _int_dup (self) : NULL;
}


static gint icp_lua_binding_l_set_color (lua_State* vm) {
	gint result = 0;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	if (!lua_istable (vm, 1)) {
		result = 0;
		return result;
	}
	lua_checkstack (vm, 2);
	{
		gboolean _tmp0_;
		lua_pushnil (vm);
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			char* k;
			char* v;
			gint i;
			gboolean underlined;
			gint* foreground;
			gint* background;
			const char* _tmp13_;
			GQuark _tmp14_;
			static GQuark _tmp14__label0 = 0;
			static GQuark _tmp14__label1 = 0;
			static GQuark _tmp14__label2 = 0;
			static GQuark _tmp14__label3 = 0;
			static GQuark _tmp14__label4 = 0;
			static GQuark _tmp14__label5 = 0;
			static GQuark _tmp14__label6 = 0;
			static GQuark _tmp14__label7 = 0;
			if (!_tmp0_) {
				lua_pop (vm, 1);
			}
			_tmp0_ = FALSE;
			if (!(lua_next (vm, 1) != 0)) {
				break;
			}
			if (!lua_isstring (vm, -1)) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = !lua_isstring (vm, -2);
			}
			if (_tmp1_) {
				continue;
			}
			k = g_strdup (lua_tostring (vm, -2));
			v = g_strdup (lua_tostring (vm, -1));
			i = 0;
			underlined = FALSE;
			foreground = NULL;
			background = NULL;
			{
				char** _tmp2_;
				char** s_collection;
				int s_collection_length1;
				int s_it;
				s_collection = _tmp2_ = g_strsplit (v, ",", 0);
				s_collection_length1 = _vala_array_length (_tmp2_);
				for (s_it = 0; s_it < _vala_array_length (_tmp2_); s_it = s_it + 1) {
					char* s;
					s = g_strdup (s_collection[s_it]);
					{
						gint t;
						t = -1;
						sscanf (s, "%x", &t);
						switch (i) {
							case 0:
							{
								if (t != (-1)) {
									gint* _tmp3_;
									foreground = (_tmp3_ = __int_dup0 (&t), _g_free0 (foreground), _tmp3_);
								}
								break;
							}
							case 1:
							{
								if (t != (-1)) {
									gint* _tmp4_;
									background = (_tmp4_ = __int_dup0 (&t), _g_free0 (background), _tmp4_);
								}
								break;
							}
							case 2:
							{
								underlined = t > 0;
								break;
							}
						}
						i++;
						_g_free0 (s);
					}
				}
				s_collection = (_vala_array_free (s_collection, s_collection_length1, (GDestroyNotify) g_free), NULL);
			}
			_tmp13_ = k;
			_tmp14_ = (NULL == _tmp13_) ? 0 : g_quark_from_string (_tmp13_);
			if (_tmp14_ == ((0 != _tmp14__label0) ? _tmp14__label0 : (_tmp14__label0 = g_quark_from_static_string ("buffer_raw"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp5_;
					icp_config_colors_buffer_raw = (_tmp5_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_buffer_raw), _tmp5_);
					break;
				}
			} else if (_tmp14_ == ((0 != _tmp14__label1) ? _tmp14__label1 : (_tmp14__label1 = g_quark_from_static_string ("buffer_pinyin"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp6_;
					icp_config_colors_buffer_pinyin = (_tmp6_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_buffer_pinyin), _tmp6_);
					break;
				}
			} else if (_tmp14_ == ((0 != _tmp14__label2) ? _tmp14__label2 : (_tmp14__label2 = g_quark_from_static_string ("candidate_local"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp7_;
					icp_config_colors_candidate_local = (_tmp7_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_candidate_local), _tmp7_);
					break;
				}
			} else if (_tmp14_ == ((0 != _tmp14__label3) ? _tmp14__label3 : (_tmp14__label3 = g_quark_from_static_string ("candidate_remote"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp8_;
					icp_config_colors_candidate_remote = (_tmp8_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_candidate_remote), _tmp8_);
					break;
				}
			} else if (_tmp14_ == ((0 != _tmp14__label4) ? _tmp14__label4 : (_tmp14__label4 = g_quark_from_static_string ("preedit_correcting"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp9_;
					icp_config_colors_preedit_correcting = (_tmp9_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_preedit_correcting), _tmp9_);
					break;
				}
			} else if (_tmp14_ == ((0 != _tmp14__label5) ? _tmp14__label5 : (_tmp14__label5 = g_quark_from_static_string ("preedit_local"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp10_;
					icp_config_colors_preedit_local = (_tmp10_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_preedit_local), _tmp10_);
					break;
				}
			} else if (_tmp14_ == ((0 != _tmp14__label6) ? _tmp14__label6 : (_tmp14__label6 = g_quark_from_static_string ("preedit_remote"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp11_;
					icp_config_colors_preedit_remote = (_tmp11_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_preedit_remote), _tmp11_);
					break;
				}
			} else if (_tmp14_ == ((0 != _tmp14__label7) ? _tmp14__label7 : (_tmp14__label7 = g_quark_from_static_string ("preedit_fixed"))))
			switch (0) {
				default:
				{
					icpConfigColorsColor* _tmp12_;
					icp_config_colors_preedit_fixed = (_tmp12_ = icp_config_colors_color_new (foreground, background, underlined), _icp_config_colors_color_unref0 (icp_config_colors_preedit_fixed), _tmp12_);
					break;
				}
			}
			_g_free0 (background);
			_g_free0 (foreground);
			_g_free0 (v);
			_g_free0 (k);
		}
	}
	result = 0;
	return result;
}


static gint icp_lua_binding_l_set_switch (lua_State* vm) {
	gint result = 0;
	g_return_val_if_fail (vm != NULL, 0);
	if (!lua_istable (vm, 1)) {
		result = 0;
		return result;
	}
	lua_checkstack (vm, 2);
	{
		gboolean _tmp0_;
		lua_pushnil (vm);
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			char* k;
			gboolean v;
			gboolean* bind_value;
			const char* _tmp2_;
			GQuark _tmp3_;
			static GQuark _tmp3__label0 = 0;
			static GQuark _tmp3__label1 = 0;
			static GQuark _tmp3__label2 = 0;
			static GQuark _tmp3__label3 = 0;
			static GQuark _tmp3__label4 = 0;
			static GQuark _tmp3__label5 = 0;
			static GQuark _tmp3__label6 = 0;
			static GQuark _tmp3__label7 = 0;
			if (!_tmp0_) {
				lua_pop (vm, 1);
			}
			_tmp0_ = FALSE;
			if (!(lua_next (vm, 1) != 0)) {
				break;
			}
			if (!lua_isboolean (vm, -1)) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = !lua_isstring (vm, -2);
			}
			if (_tmp1_) {
				continue;
			}
			k = g_strdup (lua_tostring (vm, -2));
			v = lua_toboolean (vm, -1);
			bind_value = NULL;
			_tmp2_ = k;
			_tmp3_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
			if (_tmp3_ == ((0 != _tmp3__label0) ? _tmp3__label0 : (_tmp3__label0 = g_quark_from_static_string ("double_pinyin"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_double_pinyin;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label1) ? _tmp3__label1 : (_tmp3__label1 = g_quark_from_static_string ("background_request"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_background_request;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label2) ? _tmp3__label2 : (_tmp3__label2 = g_quark_from_static_string ("always_show_candidates"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_always_show_candidates;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label3) ? _tmp3__label3 : (_tmp3__label3 = g_quark_from_static_string ("show_pinyin_auxiliary"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_show_pinyin_auxiliary;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label4) ? _tmp3__label4 : (_tmp3__label4 = g_quark_from_static_string ("show_raw_in_auxiliary"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_show_raw_in_auxiliary;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label5) ? _tmp3__label5 : (_tmp3__label5 = g_quark_from_static_string ("default_offline_mode"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_default_offline_mode;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label6) ? _tmp3__label6 : (_tmp3__label6 = g_quark_from_static_string ("default_chinese_mode"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_default_chinese_mode;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label7) ? _tmp3__label7 : (_tmp3__label7 = g_quark_from_static_string ("default_traditional_mode"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_switches_default_traditional_mode;
					break;
				}
			}
			*bind_value = v;
			_g_free0 (k);
		}
	}
	result = 0;
	return result;
}


static gint icp_lua_binding_l_set_timeout (lua_State* vm) {
	gint result = 0;
	g_return_val_if_fail (vm != NULL, 0);
	if (!lua_istable (vm, 1)) {
		result = 0;
		return result;
	}
	lua_checkstack (vm, 2);
	{
		gboolean _tmp0_;
		lua_pushnil (vm);
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			char* k;
			double v;
			double* bind_value;
			const char* _tmp2_;
			GQuark _tmp3_;
			static GQuark _tmp3__label0 = 0;
			static GQuark _tmp3__label1 = 0;
			static GQuark _tmp3__label2 = 0;
			if (!_tmp0_) {
				lua_pop (vm, 1);
			}
			_tmp0_ = FALSE;
			if (!(lua_next (vm, 1) != 0)) {
				break;
			}
			if (!lua_isnumber (vm, -1)) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = !lua_isstring (vm, -2);
			}
			if (_tmp1_) {
				continue;
			}
			k = g_strdup (lua_tostring (vm, -2));
			v = lua_tonumber (vm, -1);
			bind_value = NULL;
			_tmp2_ = k;
			_tmp3_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
			if (_tmp3_ == ((0 != _tmp3__label0) ? _tmp3__label0 : (_tmp3__label0 = g_quark_from_static_string ("request"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_timeouts_request;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label1) ? _tmp3__label1 : (_tmp3__label1 = g_quark_from_static_string ("prerequest"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_timeouts_prerequest;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label2) ? _tmp3__label2 : (_tmp3__label2 = g_quark_from_static_string ("selection"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_timeouts_selection;
					break;
				}
			}
			*bind_value = v;
			_g_free0 (k);
		}
	}
	result = 0;
	return result;
}


static gint icp_lua_binding_l_set_limit (lua_State* vm) {
	gint result = 0;
	g_return_val_if_fail (vm != NULL, 0);
	if (!lua_istable (vm, 1)) {
		result = 0;
		return result;
	}
	lua_checkstack (vm, 2);
	{
		gboolean _tmp0_;
		lua_pushnil (vm);
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			char* k;
			gint v;
			gint* bind_value;
			const char* _tmp2_;
			GQuark _tmp3_;
			static GQuark _tmp3__label0 = 0;
			static GQuark _tmp3__label1 = 0;
			static GQuark _tmp3__label2 = 0;
			static GQuark _tmp3__label3 = 0;
			if (!_tmp0_) {
				lua_pop (vm, 1);
			}
			_tmp0_ = FALSE;
			if (!(lua_next (vm, 1) != 0)) {
				break;
			}
			if (!lua_isnumber (vm, -1)) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = !lua_isstring (vm, -2);
			}
			if (_tmp1_) {
				continue;
			}
			k = g_strdup (lua_tostring (vm, -2));
			v = lua_tointeger (vm, -1);
			bind_value = NULL;
			_tmp2_ = k;
			_tmp3_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
			if (_tmp3_ == ((0 != _tmp3__label0) ? _tmp3__label0 : (_tmp3__label0 = g_quark_from_static_string ("db_query_limit"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_limits_db_query_limit;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label1) ? _tmp3__label1 : (_tmp3__label1 = g_quark_from_static_string ("prerequest_retry_limit"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_limits_prerequest_retry_limit;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label2) ? _tmp3__label2 : (_tmp3__label2 = g_quark_from_static_string ("request_retry_limit"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_limits_request_retry_limit;
					break;
				}
			} else if (_tmp3_ == ((0 != _tmp3__label3) ? _tmp3__label3 : (_tmp3__label3 = g_quark_from_static_string ("cloud_candidates_limit"))))
			switch (0) {
				default:
				{
					bind_value = &icp_config_limits_cloud_candidates_limit;
					break;
				}
			}
			*bind_value = v;
			_g_free0 (k);
		}
	}
	result = 0;
	return result;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


static gint icp_lua_binding_l_set_double_pinyin (lua_State* vm) {
	gint result = 0;
	gint vm_top;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	icp_pinyin_double_pinyin_clear ();
	if (!lua_istable (vm, 1)) {
		result = 0;
		return result;
	}
	vm_top = lua_gettop (vm);
	lua_checkstack (vm, 2);
	{
		gboolean _tmp0_;
		lua_pushnil (vm);
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			char* double_pinyin;
			char* full_pinyin;
			if (!_tmp0_) {
				lua_pop (vm, 1);
			}
			_tmp0_ = FALSE;
			if (!(lua_next (vm, 1) != 0)) {
				break;
			}
			if (!lua_isstring (vm, -1)) {
				_tmp1_ = TRUE;
			} else {
				_tmp1_ = !lua_isstring (vm, -2);
			}
			if (_tmp1_) {
				continue;
			}
			double_pinyin = g_strdup (lua_tostring (vm, -2));
			full_pinyin = g_strdup (lua_tostring (vm, -1));
			if (string_get_length (double_pinyin) > 2) {
				_g_free0 (full_pinyin);
				_g_free0 (double_pinyin);
				continue;
			}
			icp_pinyin_double_pinyin_insert (double_pinyin, full_pinyin);
			_g_free0 (full_pinyin);
			_g_free0 (double_pinyin);
		}
	}
	g_assert (lua_gettop (vm) == vm_top);
	result = 0;
	return result;
}


static gint icp_lua_binding_l_set_key (lua_State* vm) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	guint key_value;
	icpConfigKey* key;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	if (lua_gettop (vm) < 3) {
		_tmp2_ = TRUE;
	} else {
		gboolean _tmp3_ = FALSE;
		if (lua_type (vm, 1) == LUA_TSTRING) {
			_tmp3_ = TRUE;
		} else {
			_tmp3_ = lua_type (vm, 1) == LUA_TNUMBER;
		}
		_tmp2_ = !_tmp3_;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = !lua_isstring (vm, 3);
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = !lua_isnumber (vm, 2);
	}
	if (_tmp0_) {
		result = 0;
		return result;
	}
	key_value = (guint) 0;
	if (lua_type (vm, 1) == LUA_TSTRING) {
		char* s;
		s = g_strdup (lua_tostring (vm, 1));
		if (string_get_length (s) > 0) {
			key_value = (guint) g_utf8_get_char (g_utf8_offset_to_pointer (s, 0));
		}
		_g_free0 (s);
	} else {
		key_value = (guint) lua_tointeger (vm, 1);
	}
	if (key_value == 0) {
		result = 0;
		return result;
	}
	key = icp_config_key_new (key_value, (guint) lua_tointeger (vm, 2), NULL);
	icp_config_key_actions_set (key, lua_tostring (vm, 3));
	result = 0;
	_icp_config_key_unref0 (key);
	return result;
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


static gint icp_lua_binding_l_set_candidate_labels (lua_State* vm) {
	gint result = 0;
	char* labels;
	char* alternative_labels;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	if (!lua_isstring (vm, 1)) {
		result = 0;
		return result;
	}
	labels = g_strdup (lua_tostring (vm, 1));
	alternative_labels = g_strdup (labels);
	if (lua_isstring (vm, 2)) {
		char* _tmp0_;
		alternative_labels = (_tmp0_ = g_strdup (lua_tostring (vm, 2)), _g_free0 (alternative_labels), _tmp0_);
	}
	icp_config_candidate_labels_clear ();
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				char* _tmp2_;
				char* _tmp5_;
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < string_get_length (labels))) {
					break;
				}
				_tmp2_ = NULL;
				if (i < string_get_length (alternative_labels)) {
					char* _tmp3_;
					_tmp2_ = (_tmp3_ = string_slice (alternative_labels, (glong) i, (glong) (i + 1)), _g_free0 (_tmp2_), _tmp3_);
				} else {
					char* _tmp4_;
					_tmp2_ = (_tmp4_ = NULL, _g_free0 (_tmp2_), _tmp4_);
				}
				icp_config_candidate_labels_add (_tmp5_ = string_slice (labels, (glong) i, (glong) (i + 1)), _tmp2_);
				_g_free0 (_tmp5_);
				_g_free0 (_tmp2_);
			}
		}
	}
	result = 0;
	_g_free0 (alternative_labels);
	_g_free0 (labels);
	return result;
}


static gint icp_lua_binding_l_set_punctuation (lua_State* vm) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean only_after_chinese;
	gint half_punc = 0;
	char* full_punc;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	if (lua_type (vm, 1) == LUA_TNUMBER) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = lua_type (vm, 1) == LUA_TSTRING;
	}
	if (!_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = !lua_isstring (vm, 2);
	}
	if (_tmp0_) {
		result = 0;
		return result;
	}
	only_after_chinese = FALSE;
	if (!lua_isboolean (vm, 3)) {
		only_after_chinese = lua_toboolean (vm, 3);
	}
	if (lua_type (vm, 1) == LUA_TNUMBER) {
		half_punc = lua_tointeger (vm, 1);
	} else {
		char* half_punc_str;
		half_punc_str = g_strdup (lua_tostring (vm, 1));
		if (string_get_length (half_punc_str) == 0) {
			result = 0;
			_g_free0 (half_punc_str);
			return result;
		}
		half_punc = (gint) g_utf8_get_char (g_utf8_offset_to_pointer (half_punc_str, 0));
		_g_free0 (half_punc_str);
	}
	full_punc = g_strdup (lua_tostring (vm, 2));
	icp_config_punctuations_set (half_punc, full_punc, only_after_chinese);
	result = 0;
	_g_free0 (full_punc);
	return result;
}


static gint icp_lua_binding_l_register_engine (lua_State* vm) {
	gint result = 0;
	char* name;
	char* script_filename;
	gint priority;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (vm != NULL, 0);
	if (!icp_lua_binding_check_permissions (TRUE)) {
		result = 0;
		return result;
	}
	if (!lua_isstring (vm, 1)) {
		result = 0;
		return result;
	}
	name = g_strdup (lua_tostring (vm, 1));
	script_filename = g_strdup ("");
	if (lua_isstring (vm, 2)) {
		char* _tmp0_;
		script_filename = (_tmp0_ = g_strdup (lua_tostring (vm, 2)), _g_free0 (script_filename), _tmp0_);
	}
	priority = 1;
	if (lua_isnumber (vm, 3)) {
		priority = lua_tointeger (vm, 3);
	}
	if (string_get_length (script_filename) == 0) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = priority <= 0;
	}
	if (_tmp1_) {
		if (gee_abstract_map_has_key (GEE_ABSTRACT_MAP (icp_lua_binding_engines), name)) {
			gee_abstract_map_unset (GEE_ABSTRACT_MAP (icp_lua_binding_engines), name, NULL);
		}
	} else {
		icpLuaBindingCloudEngine* _tmp2_;
		gee_abstract_map_set (GEE_ABSTRACT_MAP (icp_lua_binding_engines), name, _tmp2_ = icp_lua_binding_cloud_engine_new (script_filename, priority));
		_icp_lua_binding_cloud_engine_unref0 (_tmp2_);
	}
	result = 0;
	_g_free0 (script_filename);
	_g_free0 (name);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gint icp_lua_binding_l_commit (lua_State* vm) {
	gint result = 0;
	char* content;
	g_return_val_if_fail (vm != NULL, 0);
	if (!lua_isstring (vm, 1)) {
		result = 0;
		return result;
	}
	content = g_strdup (lua_tostring (vm, 1));
	if (icp_ibus_binding_active_engine != NULL) {
		icpIBusBindingCloudPinyinEngine* engine;
		engine = _g_object_ref0 (icp_ibus_binding_active_engine);
		if (engine != NULL) {
			icp_ibus_binding_cloud_pinyin_engine_commit (engine, content);
		}
		_g_object_unref0 (engine);
	}
	result = 0;
	_g_free0 (content);
	return result;
}


static gint _icp_lua_binding_l_notify_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_notify (vm);
	return result;
}


static gint _icp_lua_binding_l_get_selection_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_get_selection (vm);
	return result;
}


static gint _icp_lua_binding_l_commit_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_commit (vm);
	return result;
}


static gint _icp_lua_binding_l_set_response_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_response (vm);
	return result;
}


static gint _icp_lua_binding_l_set_double_pinyin_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_double_pinyin (vm);
	return result;
}


static gint _icp_lua_binding_l_set_key_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_key (vm);
	return result;
}


static gint _icp_lua_binding_l_set_candidate_labels_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_candidate_labels (vm);
	return result;
}


static gint _icp_lua_binding_l_set_punctuation_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_punctuation (vm);
	return result;
}


static gint _icp_lua_binding_l_set_switch_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_switch (vm);
	return result;
}


static gint _icp_lua_binding_l_set_timeout_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_timeout (vm);
	return result;
}


static gint _icp_lua_binding_l_set_limit_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_limit (vm);
	return result;
}


static gint _icp_lua_binding_l_set_color_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_color (vm);
	return result;
}


static gint _icp_lua_binding_l_set_cutting_adjust_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_set_cutting_adjust (vm);
	return result;
}


static gint _icp_lua_binding_l_register_engine_lua_cfunction (lua_State* vm) {
	gint result;
	result = icp_lua_binding_l_register_engine (vm);
	return result;
}


static void _icp_lua_binding_do_string_internal_gfunc (void* data, gpointer self) {
	icp_lua_binding_do_string_internal (data);
}


void icp_lua_binding_init (void) {
	GeeLinkedList* _tmp0_;
	GeeHashMap* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeHashMap* _tmp3_;
	lua_State* _tmp4_;
	GError * _inner_error_ = NULL;
	icp_lua_binding_in_configuration = FALSE;
	icp_lua_binding_script_pool = (_tmp0_ = gee_linked_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL), _g_object_unref0 (icp_lua_binding_script_pool), _tmp0_);
	icp_lua_binding_engines = (_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, ICP_LUA_BINDING_TYPE_CLOUD_ENGINE, (GBoxedCopyFunc) icp_lua_binding_cloud_engine_ref, icp_lua_binding_cloud_engine_unref, NULL, NULL, NULL), _g_object_unref0 (icp_lua_binding_engines), _tmp1_);
	icp_lua_binding_request_group = (_tmp2_ = gee_array_list_new (ICP_LUA_BINDING_TYPE_REQUEST_GROUP, (GBoxedCopyFunc) icp_lua_binding_request_group_ref, icp_lua_binding_request_group_unref, NULL), _g_object_unref0 (icp_lua_binding_request_group), _tmp2_);
	icp_lua_binding_pid_to_request_status = (_tmp3_ = gee_hash_map_new (G_TYPE_LONG, NULL, NULL, ICP_LUA_BINDING_TYPE_REQUEST_STATUS, (GBoxedCopyFunc) icp_lua_binding_request_status_ref, icp_lua_binding_request_status_unref, NULL, NULL, NULL), _g_object_unref0 (icp_lua_binding_pid_to_request_status), _tmp3_);
	icp_lua_binding_vm = (_tmp4_ = (lua_State*) luaL_newstate (), _lua_close0 (icp_lua_binding_vm), _tmp4_);
	luaL_openlibs (icp_lua_binding_vm);
	lua_checkstack (icp_lua_binding_vm, 1);
	lua_pushstring (icp_lua_binding_vm, icp_config_get_user_config_path ());
	lua_setglobal (icp_lua_binding_vm, "user_config_path");
	lua_pushstring (icp_lua_binding_vm, icp_config_get_user_data_path ());
	lua_setglobal (icp_lua_binding_vm, "user_data_path");
	lua_pushstring (icp_lua_binding_vm, icp_config_get_user_cache_path ());
	lua_setglobal (icp_lua_binding_vm, "user_cache_path");
	lua_pushstring (icp_lua_binding_vm, icp_config_get_global_data_path ());
	lua_setglobal (icp_lua_binding_vm, "data_path");
	lua_register (icp_lua_binding_vm, "notify", _icp_lua_binding_l_notify_lua_cfunction);
	lua_register (icp_lua_binding_vm, "get_selection", _icp_lua_binding_l_get_selection_lua_cfunction);
	lua_register (icp_lua_binding_vm, "commit", _icp_lua_binding_l_commit_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_response", _icp_lua_binding_l_set_response_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_double_pinyin", _icp_lua_binding_l_set_double_pinyin_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_key", _icp_lua_binding_l_set_key_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_candidate_labels", _icp_lua_binding_l_set_candidate_labels_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_punctuation", _icp_lua_binding_l_set_punctuation_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_switch", _icp_lua_binding_l_set_switch_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_timeout", _icp_lua_binding_l_set_timeout_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_limit", _icp_lua_binding_l_set_limit_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_color", _icp_lua_binding_l_set_color_lua_cfunction);
	lua_register (icp_lua_binding_vm, "set_cutting_adjust", _icp_lua_binding_l_set_cutting_adjust_lua_cfunction);
	lua_register (icp_lua_binding_vm, "register_engine", _icp_lua_binding_l_register_engine_lua_cfunction);
	{
		GThreadPool* _tmp5_;
		GThreadPool* _tmp6_;
		_tmp5_ = g_thread_pool_new (_icp_lua_binding_do_string_internal_gfunc, NULL, 1, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_THREAD_ERROR) {
				goto __catch11_g_thread_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		icp_lua_binding_thread_pool = (_tmp6_ = _tmp5_, _g_thread_pool_free0 (icp_lua_binding_thread_pool), _tmp6_);
	}
	goto __finally11;
	__catch11_g_thread_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "LuaBinding cannot create thread pool: %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally11:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	icp_lua_binding_load_configuration ();
}


static void icp_lua_binding_do_string_internal (void* data) {
	char* script;
	const char* _tmp0_;
	GQuark _tmp1_;
	static GQuark _tmp1__label0 = 0;
	script = g_strdup ((const char*) data);
	_tmp0_ = script;
	_tmp1_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp1_ == ((0 != _tmp1__label0) ? _tmp1__label0 : (_tmp1__label0 = g_quark_from_static_string (".stop_conf"))))
	switch (0) {
		default:
		{
			icp_lua_binding_in_configuration = FALSE;
			break;
		}
	} else
	switch (0) {
		default:
		{
			luaL_loadstring (icp_lua_binding_vm, script);
			if (lua_pcall (icp_lua_binding_vm, 0, 0, 0) != 0) {
				char* error_message;
				error_message = g_strdup (lua_tostring (icp_lua_binding_vm, -1));
				if (_vala_strcmp0 (error_message, "fork_stop") != 0) {
					icp_frontend_notify ("Lua Error", error_message, "error");
				}
				lua_pop (icp_lua_binding_vm, 1);
				_g_free0 (error_message);
			}
			break;
		}
	}
	_g_free0 (script);
}


void icp_lua_binding_do_string (const char* script) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (script != NULL);
	{
		if (g_thread_pool_unprocessed (icp_lua_binding_thread_pool) == 0) {
			gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (icp_lua_binding_script_pool));
		}
		gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (icp_lua_binding_script_pool), script);
		g_thread_pool_push (icp_lua_binding_thread_pool, (void*) ((char*) gee_abstract_list_last (GEE_ABSTRACT_LIST (icp_lua_binding_script_pool))), &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_THREAD_ERROR) {
				goto __catch12_g_thread_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally12;
	__catch12_g_thread_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "LuaBinding fails to launch thread from thread pool: %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally12:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void icp_lua_binding_load_configuration (void) {
	char* _tmp0_;
	icp_lua_binding_in_configuration = TRUE;
	icp_lua_binding_do_string (_tmp0_ = g_strdup_printf ("dofile([[%s]])", icp_config_commandline_options_startup_script));
	_g_free0 (_tmp0_);
	icp_lua_binding_do_string (".stop_conf");
}


static icpLuaBindingCloudEngine* icp_lua_binding_cloud_engine_construct (GType object_type, const char* script, gint priority) {
	icpLuaBindingCloudEngine* self = (icpLuaBindingCloudEngine*) g_type_create_instance (object_type);
	g_return_val_if_fail (script != NULL, NULL);
	icp_lua_binding_cloud_engine_set_priority (self, priority);
	icp_lua_binding_cloud_engine_set_script (self, script);
	self->response_time_rank = (double) 2;
	self->response_count = 0;
	self->response_time = (double) 0;
	return self;
}


static icpLuaBindingCloudEngine* icp_lua_binding_cloud_engine_new (const char* script, gint priority) {
	return icp_lua_binding_cloud_engine_construct (ICP_LUA_BINDING_TYPE_CLOUD_ENGINE, script, priority);
}


static void icp_lua_binding_cloud_engine_update_response_time_rank (icpLuaBindingCloudEngine* self, double time, gboolean successful, double timeout) {
	double t;
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (ICP_LUA_BINDING_IS_CLOUD_ENGINE (self));
	t = time / 3;
	if (t > 1) {
		t = (double) 1;
	}
	if (t < 0) {
		t = (double) 0;
	}
	if (!successful) {
		t = (double) 1;
	}
	if (t < 1) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = timeout > 3;
	}
	if (_tmp0_) {
		{
			g_static_rec_mutex_lock (&self->priv->__lock_response_time_rank);
			{
				if (self->response_time_rank > 1) {
					self->response_time_rank = t;
				} else {
					self->response_time_rank = (self->response_time_rank * 0.9) + (t * 0.1);
				}
			}
			__finally13:
			{
				g_static_rec_mutex_unlock (&self->priv->__lock_response_time_rank);
			}
			if (_inner_error_ != NULL) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	if (successful) {
		self->response_time = self->response_time + time;
		self->response_count++;
	}
}


static gint icp_lua_binding_cloud_engine_get_priority (icpLuaBindingCloudEngine* self) {
	gint result;
	g_return_val_if_fail (ICP_LUA_BINDING_IS_CLOUD_ENGINE (self), 0);
	result = self->priv->_priority;
	return result;
}


static void icp_lua_binding_cloud_engine_set_priority (icpLuaBindingCloudEngine* self, gint value) {
	g_return_if_fail (ICP_LUA_BINDING_IS_CLOUD_ENGINE (self));
	self->priv->_priority = value;
}


static const char* icp_lua_binding_cloud_engine_get_script (icpLuaBindingCloudEngine* self) {
	const char* result;
	g_return_val_if_fail (ICP_LUA_BINDING_IS_CLOUD_ENGINE (self), NULL);
	result = self->priv->_script;
	return result;
}


static void icp_lua_binding_cloud_engine_set_script (icpLuaBindingCloudEngine* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (ICP_LUA_BINDING_IS_CLOUD_ENGINE (self));
	self->priv->_script = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_script), _tmp0_);
}


static void icp_lua_binding_value_cloud_engine_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_lua_binding_value_cloud_engine_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_lua_binding_cloud_engine_unref (value->data[0].v_pointer);
	}
}


static void icp_lua_binding_value_cloud_engine_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_lua_binding_cloud_engine_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_lua_binding_value_cloud_engine_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_lua_binding_value_cloud_engine_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpLuaBindingCloudEngine* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_lua_binding_cloud_engine_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_lua_binding_value_cloud_engine_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpLuaBindingCloudEngine** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_lua_binding_cloud_engine_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* icp_lua_binding_param_spec_cloud_engine (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpLuaBindingParamSpecCloudEngine* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_LUA_BINDING_TYPE_CLOUD_ENGINE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer icp_lua_binding_value_get_cloud_engine (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_CLOUD_ENGINE), NULL);
	return value->data[0].v_pointer;
}


static void icp_lua_binding_value_set_cloud_engine (GValue* value, gpointer v_object) {
	icpLuaBindingCloudEngine* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_CLOUD_ENGINE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_LUA_BINDING_TYPE_CLOUD_ENGINE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_lua_binding_cloud_engine_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_cloud_engine_unref (old);
	}
}


static void icp_lua_binding_value_take_cloud_engine (GValue* value, gpointer v_object) {
	icpLuaBindingCloudEngine* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_CLOUD_ENGINE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_LUA_BINDING_TYPE_CLOUD_ENGINE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_cloud_engine_unref (old);
	}
}


static void icp_lua_binding_cloud_engine_class_init (icpLuaBindingCloudEngineClass * klass) {
	icp_lua_binding_cloud_engine_parent_class = g_type_class_peek_parent (klass);
	ICP_LUA_BINDING_CLOUD_ENGINE_CLASS (klass)->finalize = icp_lua_binding_cloud_engine_finalize;
	g_type_class_add_private (klass, sizeof (icpLuaBindingCloudEnginePrivate));
}


static void icp_lua_binding_cloud_engine_instance_init (icpLuaBindingCloudEngine * self) {
	self->priv = ICP_LUA_BINDING_CLOUD_ENGINE_GET_PRIVATE (self);
	g_static_rec_mutex_init (&self->priv->__lock_response_time_rank);
	self->ref_count = 1;
}


static void icp_lua_binding_cloud_engine_finalize (icpLuaBindingCloudEngine* obj) {
	icpLuaBindingCloudEngine * self;
	self = ICP_LUA_BINDING_CLOUD_ENGINE (obj);
	g_static_rec_mutex_free (&self->priv->__lock_response_time_rank);
	_g_free0 (self->priv->_script);
}


static GType icp_lua_binding_cloud_engine_get_type (void) {
	static volatile gsize icp_lua_binding_cloud_engine_type_id__volatile = 0;
	if (g_once_init_enter (&icp_lua_binding_cloud_engine_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_lua_binding_value_cloud_engine_init, icp_lua_binding_value_cloud_engine_free_value, icp_lua_binding_value_cloud_engine_copy_value, icp_lua_binding_value_cloud_engine_peek_pointer, "p", icp_lua_binding_value_cloud_engine_collect_value, "p", icp_lua_binding_value_cloud_engine_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpLuaBindingCloudEngineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_lua_binding_cloud_engine_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpLuaBindingCloudEngine), 0, (GInstanceInitFunc) icp_lua_binding_cloud_engine_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_lua_binding_cloud_engine_type_id;
		icp_lua_binding_cloud_engine_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpLuaBindingCloudEngine", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_lua_binding_cloud_engine_type_id__volatile, icp_lua_binding_cloud_engine_type_id);
	}
	return icp_lua_binding_cloud_engine_type_id__volatile;
}


static gpointer icp_lua_binding_cloud_engine_ref (gpointer instance) {
	icpLuaBindingCloudEngine* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void icp_lua_binding_cloud_engine_unref (gpointer instance) {
	icpLuaBindingCloudEngine* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_LUA_BINDING_CLOUD_ENGINE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gpointer _icp_lua_binding_request_group_ref0 (gpointer self) {
	return self ? icp_lua_binding_request_group_ref (self) : NULL;
}


static gpointer _icp_lua_binding_cloud_engine_ref0 (gpointer self) {
	return self ? icp_lua_binding_cloud_engine_ref (self) : NULL;
}


static void _lambda3_ (GPid p, gint status, icpLuaBindingRequestStatus* self) {
	gboolean successful;
	icpLuaBindingRequestStatus* rs;
	gboolean _tmp0_ = FALSE;
	successful = status == 0;
	g_assert (gee_abstract_map_has_key (GEE_ABSTRACT_MAP (icp_lua_binding_pid_to_request_status), GINT_TO_POINTER ((glong) p)));
	rs = (icpLuaBindingRequestStatus*) gee_abstract_map_get (GEE_ABSTRACT_MAP (icp_lua_binding_pid_to_request_status), GINT_TO_POINTER ((glong) p));
	gee_abstract_map_unset (GEE_ABSTRACT_MAP (icp_lua_binding_pid_to_request_status), GINT_TO_POINTER ((glong) p), NULL);
	g_assert (rs->pid == p);
	if (status != 15) {
		icp_lua_binding_cloud_engine_update_response_time_rank (rs->priv->engine, ((icp_database_get_atime () - rs->priv->start_time) * 3600) * 24, successful, rs->priv->group->timeout);
	}
	if (successful) {
		_tmp0_ = icp_lua_binding_cloud_engine_get_priority (rs->priv->engine) == rs->priv->group->highest_priority;
	} else {
		_tmp0_ = FALSE;
	}
	icp_lua_binding_request_group_notify_done (rs->priv->group, rs->priv->_id, _tmp0_);
	g_spawn_close_pid (p);
	_icp_lua_binding_request_status_unref0 (rs);
}


static void __lambda3__gchild_watch_func (GPid pid, gint status, gpointer self) {
	_lambda3_ (pid, status, self);
}


static icpLuaBindingRequestStatus* icp_lua_binding_request_status_construct (GType object_type, icpLuaBindingRequestGroup* group, icpLuaBindingCloudEngine* engine, gint status_id) {
	icpLuaBindingRequestStatus* self = (icpLuaBindingRequestStatus*) g_type_create_instance (object_type);
	icpLuaBindingRequestGroup* _tmp0_;
	icpLuaBindingCloudEngine* _tmp1_;
	gint argv_length1;
	gint _argv_size_;
	char** _tmp3_;
	char** _tmp2_ = NULL;
	char** argv;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ICP_LUA_BINDING_IS_REQUEST_GROUP (group), NULL);
	g_return_val_if_fail (ICP_LUA_BINDING_IS_CLOUD_ENGINE (engine), NULL);
	icp_lua_binding_request_status_set_id (self, status_id);
	self->done = FALSE;
	self->priv->group = (_tmp0_ = _icp_lua_binding_request_group_ref0 (group), _icp_lua_binding_request_group_unref0 (self->priv->group), _tmp0_);
	self->priv->engine = (_tmp1_ = _icp_lua_binding_cloud_engine_ref0 (engine), _icp_lua_binding_cloud_engine_unref0 (self->priv->engine), _tmp1_);
	argv = (_tmp3_ = (_tmp2_ = g_new0 (char*, 9 + 1), _tmp2_[0] = g_strdup (icp_config_get_program_request ()), _tmp2_[1] = g_strdup ("-c"), _tmp2_[2] = g_strdup_printf ("%s", icp_lua_binding_cloud_engine_get_script (engine)), _tmp2_[3] = g_strdup ("-r"), _tmp2_[4] = g_strdup_printf ("%s", group->pinyins), _tmp2_[5] = g_strdup ("-p"), _tmp2_[6] = g_strdup_printf ("%d", icp_lua_binding_cloud_engine_get_priority (engine)), _tmp2_[7] = g_strdup ("-t"), _tmp2_[8] = g_strdup_printf ("%f", group->timeout), _tmp2_), argv_length1 = 9, _argv_size_ = argv_length1, _tmp3_);
	self->priv->start_time = icp_database_get_atime ();
	if (group->highest_priority < icp_lua_binding_cloud_engine_get_priority (engine)) {
		group->highest_priority = icp_lua_binding_cloud_engine_get_priority (engine);
	}
	{
		g_spawn_async (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &self->pid, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_SPAWN_ERROR) {
				goto __catch14_g_spawn_error;
			}
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		gee_abstract_map_set (GEE_ABSTRACT_MAP (icp_lua_binding_pid_to_request_status), GINT_TO_POINTER ((glong) self->pid), self);
		g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, self->pid, __lambda3__gchild_watch_func, icp_lua_binding_request_status_ref (self), icp_lua_binding_request_status_unref);
	}
	goto __finally14;
	__catch14_g_spawn_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "ERROR: Can not spawn self to send request: '%s'\n", group->pinyins);
			_g_error_free0 (e);
		}
	}
	__finally14:
	if (_inner_error_ != NULL) {
		argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
	return self;
}


static icpLuaBindingRequestStatus* icp_lua_binding_request_status_new (icpLuaBindingRequestGroup* group, icpLuaBindingCloudEngine* engine, gint status_id) {
	return icp_lua_binding_request_status_construct (ICP_LUA_BINDING_TYPE_REQUEST_STATUS, group, engine, status_id);
}


static gint icp_lua_binding_request_status_get_id (icpLuaBindingRequestStatus* self) {
	gint result;
	g_return_val_if_fail (ICP_LUA_BINDING_IS_REQUEST_STATUS (self), 0);
	result = self->priv->_id;
	return result;
}


static void icp_lua_binding_request_status_set_id (icpLuaBindingRequestStatus* self, gint value) {
	g_return_if_fail (ICP_LUA_BINDING_IS_REQUEST_STATUS (self));
	self->priv->_id = value;
}


static void icp_lua_binding_value_request_status_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_lua_binding_value_request_status_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_lua_binding_request_status_unref (value->data[0].v_pointer);
	}
}


static void icp_lua_binding_value_request_status_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_lua_binding_request_status_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_lua_binding_value_request_status_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_lua_binding_value_request_status_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpLuaBindingRequestStatus* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_lua_binding_request_status_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_lua_binding_value_request_status_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpLuaBindingRequestStatus** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_lua_binding_request_status_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* icp_lua_binding_param_spec_request_status (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpLuaBindingParamSpecRequestStatus* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_LUA_BINDING_TYPE_REQUEST_STATUS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer icp_lua_binding_value_get_request_status (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_REQUEST_STATUS), NULL);
	return value->data[0].v_pointer;
}


static void icp_lua_binding_value_set_request_status (GValue* value, gpointer v_object) {
	icpLuaBindingRequestStatus* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_REQUEST_STATUS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_LUA_BINDING_TYPE_REQUEST_STATUS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_lua_binding_request_status_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_request_status_unref (old);
	}
}


static void icp_lua_binding_value_take_request_status (GValue* value, gpointer v_object) {
	icpLuaBindingRequestStatus* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_REQUEST_STATUS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_LUA_BINDING_TYPE_REQUEST_STATUS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_request_status_unref (old);
	}
}


static void icp_lua_binding_request_status_class_init (icpLuaBindingRequestStatusClass * klass) {
	icp_lua_binding_request_status_parent_class = g_type_class_peek_parent (klass);
	ICP_LUA_BINDING_REQUEST_STATUS_CLASS (klass)->finalize = icp_lua_binding_request_status_finalize;
	g_type_class_add_private (klass, sizeof (icpLuaBindingRequestStatusPrivate));
}


static void icp_lua_binding_request_status_instance_init (icpLuaBindingRequestStatus * self) {
	self->priv = ICP_LUA_BINDING_REQUEST_STATUS_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void icp_lua_binding_request_status_finalize (icpLuaBindingRequestStatus* obj) {
	icpLuaBindingRequestStatus * self;
	self = ICP_LUA_BINDING_REQUEST_STATUS (obj);
	_icp_lua_binding_request_group_unref0 (self->priv->group);
	_icp_lua_binding_cloud_engine_unref0 (self->priv->engine);
}


static GType icp_lua_binding_request_status_get_type (void) {
	static volatile gsize icp_lua_binding_request_status_type_id__volatile = 0;
	if (g_once_init_enter (&icp_lua_binding_request_status_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_lua_binding_value_request_status_init, icp_lua_binding_value_request_status_free_value, icp_lua_binding_value_request_status_copy_value, icp_lua_binding_value_request_status_peek_pointer, "p", icp_lua_binding_value_request_status_collect_value, "p", icp_lua_binding_value_request_status_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpLuaBindingRequestStatusClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_lua_binding_request_status_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpLuaBindingRequestStatus), 0, (GInstanceInitFunc) icp_lua_binding_request_status_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_lua_binding_request_status_type_id;
		icp_lua_binding_request_status_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpLuaBindingRequestStatus", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_lua_binding_request_status_type_id__volatile, icp_lua_binding_request_status_type_id);
	}
	return icp_lua_binding_request_status_type_id__volatile;
}


static gpointer icp_lua_binding_request_status_ref (gpointer instance) {
	icpLuaBindingRequestStatus* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void icp_lua_binding_request_status_unref (gpointer instance) {
	icpLuaBindingRequestStatus* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_LUA_BINDING_REQUEST_STATUS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static icpLuaBindingRequestGroup* icp_lua_binding_request_group_construct (GType object_type, const char* pinyins, double timeout, gboolean* done) {
	icpLuaBindingRequestGroup* self = (icpLuaBindingRequestGroup*) g_type_create_instance (object_type);
	char* _tmp0_;
	GeeArrayList* _tmp1_;
	gint id;
	g_return_val_if_fail (pinyins != NULL, NULL);
	self->done = done;
	self->pinyins = (_tmp0_ = string_replace (pinyins, "ü", "v"), _g_free0 (self->pinyins), _tmp0_);
	*self->done = FALSE;
	self->timeout = timeout;
	self->can_clean = FALSE;
	self->highest_priority = 0;
	self->status_list = (_tmp1_ = gee_array_list_new (ICP_LUA_BINDING_TYPE_REQUEST_STATUS, (GBoxedCopyFunc) icp_lua_binding_request_status_ref, icp_lua_binding_request_status_unref, NULL), _g_object_unref0 (self->status_list), _tmp1_);
	id = 0;
	{
		GeeCollection* _tmp2_;
		GeeIterator* _tmp3_;
		GeeIterator* _engine_it;
		_engine_it = (_tmp3_ = gee_iterable_iterator (GEE_ITERABLE (_tmp2_ = gee_map_get_values (GEE_MAP (icp_lua_binding_engines)))), _g_object_unref0 (_tmp2_), _tmp3_);
		while (TRUE) {
			icpLuaBindingCloudEngine* engine;
			icpLuaBindingRequestStatus* _tmp4_;
			if (!gee_iterator_next (_engine_it)) {
				break;
			}
			engine = (icpLuaBindingCloudEngine*) gee_iterator_get (_engine_it);
			gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (self->status_list), _tmp4_ = icp_lua_binding_request_status_new (self, engine, id = id + 1));
			_icp_lua_binding_request_status_unref0 (_tmp4_);
			_icp_lua_binding_cloud_engine_unref0 (engine);
		}
		_g_object_unref0 (_engine_it);
	}
	return self;
}


static icpLuaBindingRequestGroup* icp_lua_binding_request_group_new (const char* pinyins, double timeout, gboolean* done) {
	return icp_lua_binding_request_group_construct (ICP_LUA_BINDING_TYPE_REQUEST_GROUP, pinyins, timeout, done);
}


static void icp_lua_binding_request_group_notify_done (icpLuaBindingRequestGroup* self, gint id, gboolean stop_others) {
	gint done_count;
	g_return_if_fail (ICP_LUA_BINDING_IS_REQUEST_GROUP (self));
	done_count = 0;
	{
		GeeIterator* _i_it;
		_i_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (self->status_list));
		while (TRUE) {
			icpLuaBindingRequestStatus* i;
			if (!gee_iterator_next (_i_it)) {
				break;
			}
			i = (icpLuaBindingRequestStatus*) gee_iterator_get (_i_it);
			if (icp_lua_binding_request_status_get_id (i) == id) {
				i->done = TRUE;
			}
			if (i->done) {
				done_count++;
			} else {
				if (stop_others) {
					kill ((pid_t) i->pid, 15);
				}
			}
			_icp_lua_binding_request_status_unref0 (i);
		}
		_g_object_unref0 (_i_it);
	}
	if (done_count == gee_collection_get_size (GEE_COLLECTION (self->status_list))) {
		*self->done = TRUE;
		self->can_clean = TRUE;
	}
}


static void icp_lua_binding_value_request_group_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_lua_binding_value_request_group_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_lua_binding_request_group_unref (value->data[0].v_pointer);
	}
}


static void icp_lua_binding_value_request_group_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_lua_binding_request_group_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_lua_binding_value_request_group_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_lua_binding_value_request_group_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpLuaBindingRequestGroup* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_lua_binding_request_group_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_lua_binding_value_request_group_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpLuaBindingRequestGroup** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_lua_binding_request_group_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* icp_lua_binding_param_spec_request_group (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpLuaBindingParamSpecRequestGroup* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_LUA_BINDING_TYPE_REQUEST_GROUP), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer icp_lua_binding_value_get_request_group (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_REQUEST_GROUP), NULL);
	return value->data[0].v_pointer;
}


static void icp_lua_binding_value_set_request_group (GValue* value, gpointer v_object) {
	icpLuaBindingRequestGroup* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_REQUEST_GROUP));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_LUA_BINDING_TYPE_REQUEST_GROUP));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_lua_binding_request_group_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_request_group_unref (old);
	}
}


static void icp_lua_binding_value_take_request_group (GValue* value, gpointer v_object) {
	icpLuaBindingRequestGroup* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_LUA_BINDING_TYPE_REQUEST_GROUP));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_LUA_BINDING_TYPE_REQUEST_GROUP));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_request_group_unref (old);
	}
}


static void icp_lua_binding_request_group_class_init (icpLuaBindingRequestGroupClass * klass) {
	icp_lua_binding_request_group_parent_class = g_type_class_peek_parent (klass);
	ICP_LUA_BINDING_REQUEST_GROUP_CLASS (klass)->finalize = icp_lua_binding_request_group_finalize;
}


static void icp_lua_binding_request_group_instance_init (icpLuaBindingRequestGroup * self) {
	self->ref_count = 1;
}


static void icp_lua_binding_request_group_finalize (icpLuaBindingRequestGroup* obj) {
	icpLuaBindingRequestGroup * self;
	self = ICP_LUA_BINDING_REQUEST_GROUP (obj);
	_g_free0 (self->pinyins);
	_g_object_unref0 (self->status_list);
}


static GType icp_lua_binding_request_group_get_type (void) {
	static volatile gsize icp_lua_binding_request_group_type_id__volatile = 0;
	if (g_once_init_enter (&icp_lua_binding_request_group_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_lua_binding_value_request_group_init, icp_lua_binding_value_request_group_free_value, icp_lua_binding_value_request_group_copy_value, icp_lua_binding_value_request_group_peek_pointer, "p", icp_lua_binding_value_request_group_collect_value, "p", icp_lua_binding_value_request_group_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpLuaBindingRequestGroupClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_lua_binding_request_group_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpLuaBindingRequestGroup), 0, (GInstanceInitFunc) icp_lua_binding_request_group_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_lua_binding_request_group_type_id;
		icp_lua_binding_request_group_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpLuaBindingRequestGroup", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_lua_binding_request_group_type_id__volatile, icp_lua_binding_request_group_type_id);
	}
	return icp_lua_binding_request_group_type_id__volatile;
}


static gpointer icp_lua_binding_request_group_ref (gpointer instance) {
	icpLuaBindingRequestGroup* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void icp_lua_binding_request_group_unref (gpointer instance) {
	icpLuaBindingRequestGroup* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_LUA_BINDING_REQUEST_GROUP_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void icp_value_lua_binding_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_value_lua_binding_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_lua_binding_unref (value->data[0].v_pointer);
	}
}


static void icp_value_lua_binding_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_lua_binding_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_value_lua_binding_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_value_lua_binding_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpLuaBinding* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_lua_binding_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_value_lua_binding_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpLuaBinding** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_lua_binding_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_param_spec_lua_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpParamSpecLuaBinding* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_TYPE_LUA_BINDING), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_value_get_lua_binding (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_LUA_BINDING), NULL);
	return value->data[0].v_pointer;
}


void icp_value_set_lua_binding (GValue* value, gpointer v_object) {
	icpLuaBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_LUA_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_LUA_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_lua_binding_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_unref (old);
	}
}


void icp_value_take_lua_binding (GValue* value, gpointer v_object) {
	icpLuaBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_LUA_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_LUA_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_lua_binding_unref (old);
	}
}


static void icp_lua_binding_class_init (icpLuaBindingClass * klass) {
	icp_lua_binding_parent_class = g_type_class_peek_parent (klass);
	ICP_LUA_BINDING_CLASS (klass)->finalize = icp_lua_binding_finalize;
}


static void icp_lua_binding_instance_init (icpLuaBinding * self) {
	self->ref_count = 1;
}


static void icp_lua_binding_finalize (icpLuaBinding* obj) {
	icpLuaBinding * self;
	self = ICP_LUA_BINDING (obj);
}


GType icp_lua_binding_get_type (void) {
	static volatile gsize icp_lua_binding_type_id__volatile = 0;
	if (g_once_init_enter (&icp_lua_binding_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_value_lua_binding_init, icp_value_lua_binding_free_value, icp_value_lua_binding_copy_value, icp_value_lua_binding_peek_pointer, "p", icp_value_lua_binding_collect_value, "p", icp_value_lua_binding_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpLuaBindingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_lua_binding_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpLuaBinding), 0, (GInstanceInitFunc) icp_lua_binding_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_lua_binding_type_id;
		icp_lua_binding_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpLuaBinding", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_lua_binding_type_id__volatile, icp_lua_binding_type_id);
	}
	return icp_lua_binding_type_id__volatile;
}


gpointer icp_lua_binding_ref (gpointer instance) {
	icpLuaBinding* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_lua_binding_unref (gpointer instance) {
	icpLuaBinding* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_LUA_BINDING_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




